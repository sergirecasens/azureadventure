/*!
 * Copyright (c) Microsoft and contributors. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Azure App Configuration SDK for JavaScript - 1.1.0
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
var crypto = require('crypto');
require('@azure/core-asynciterator-polyfill');
var coreTracing = require('@azure/core-tracing');
var api = require('@opentelemetry/api');

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @ignore
 */
function sha256Digest(body) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        return crypto.createHash("sha256")
            .update(body || "")
            .digest("base64");
    });
}
/**
 * @internal
 * @ignore
 */
function sha256Hmac(secret, stringToSign) {
    return tslib.__awaiter(this, void 0, void 0, function* () {
        const decodedSecret = Buffer.from(secret, "base64");
        return crypto.createHmac("sha256", decodedSecret)
            .update(stringToSign)
            .digest("base64");
    });
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @ignore
 */
class AppConfigCredential {
    constructor(credential, secret) {
        this.credential = credential;
        this.secret = secret;
    }
    /**
     * Signs a request with the values provided in the credential and secret parameter.
     *
     * @param {WebResource} webResource The WebResource to be signed.
     * @returns {Promise<WebResource>} The signed request object.
     */
    signRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const verb = webResource.method.toUpperCase();
            const utcNow = new Date().toUTCString();
            const contentHash = yield sha256Digest(webResource.body || "");
            const signedHeaders = "x-ms-date;host;x-ms-content-sha256";
            const url = coreHttp.URLBuilder.parse(webResource.url);
            const query = url.getQuery();
            const urlPathAndQuery = `${url.getPath()}${query ? "?" + query : ""}`;
            const stringToSign = `${verb}\n${urlPathAndQuery}\n${utcNow};${url.getHost()};${contentHash}`;
            const signature = yield sha256Hmac(this.secret, stringToSign);
            webResource.headers.set("x-ms-date", utcNow);
            webResource.headers.set("x-ms-content-sha256", contentHash);
            webResource.headers.set("Authorization", `HMAC-SHA256 Credential=${this.credential}, SignedHeaders=${signedHeaders}, Signature=${signature}`);
            return webResource;
        });
    }
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const Key = {
    serializedName: "Key",
    type: {
        name: "Composite",
        className: "Key",
        modelProperties: {
            name: {
                readOnly: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyValue = {
    serializedName: "KeyValue",
    type: {
        name: "Composite",
        className: "KeyValue",
        modelProperties: {
            key: {
                required: true,
                serializedName: "key",
                type: {
                    name: "String"
                }
            },
            label: {
                serializedName: "label",
                type: {
                    name: "String"
                }
            },
            contentType: {
                serializedName: "content_type",
                type: {
                    name: "String"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last_modified",
                type: {
                    name: "DateTime"
                }
            },
            tags: {
                serializedName: "tags",
                type: {
                    name: "Dictionary",
                    value: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            locked: {
                serializedName: "locked",
                type: {
                    name: "Boolean"
                }
            },
            etag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const Label = {
    serializedName: "Label",
    type: {
        name: "Composite",
        className: "Label",
        modelProperties: {
            name: {
                readOnly: true,
                serializedName: "name",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ErrorModel = {
    serializedName: "Error",
    type: {
        name: "Composite",
        className: "ErrorModel",
        modelProperties: {
            type: {
                serializedName: "type",
                type: {
                    name: "String"
                }
            },
            title: {
                serializedName: "title",
                type: {
                    name: "String"
                }
            },
            name: {
                serializedName: "name",
                type: {
                    name: "String"
                }
            },
            detail: {
                serializedName: "detail",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const KeyListResult = {
    serializedName: "KeyListResult",
    type: {
        name: "Composite",
        className: "KeyListResult",
        modelProperties: {
            items: {
                serializedName: "items",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Key"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const KeyValueListResult = {
    serializedName: "KeyValueListResult",
    type: {
        name: "Composite",
        className: "KeyValueListResult",
        modelProperties: {
            items: {
                serializedName: "items",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "KeyValue"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const LabelListResult = {
    serializedName: "LabelListResult",
    type: {
        name: "Composite",
        className: "LabelListResult",
        modelProperties: {
            items: {
                serializedName: "items",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "Label"
                        }
                    }
                }
            },
            nextLink: {
                serializedName: "@nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetKeysHeaders = {
    serializedName: "getkeys-headers",
    type: {
        name: "Composite",
        className: "GetKeysHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckKeysHeaders = {
    serializedName: "checkkeys-headers",
    type: {
        name: "Composite",
        className: "CheckKeysHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetKeyValuesHeaders = {
    serializedName: "getkeyvalues-headers",
    type: {
        name: "Composite",
        className: "GetKeyValuesHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckKeyValuesHeaders = {
    serializedName: "checkkeyvalues-headers",
    type: {
        name: "Composite",
        className: "CheckKeyValuesHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetKeyValueHeaders = {
    serializedName: "getkeyvalue-headers",
    type: {
        name: "Composite",
        className: "GetKeyValueHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModifiedHeader: {
                serializedName: "last-modified",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PutKeyValueHeaders = {
    serializedName: "putkeyvalue-headers",
    type: {
        name: "Composite",
        className: "PutKeyValueHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeleteKeyValueHeaders = {
    serializedName: "deletekeyvalue-headers",
    type: {
        name: "Composite",
        className: "DeleteKeyValueHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckKeyValueHeaders = {
    serializedName: "checkkeyvalue-headers",
    type: {
        name: "Composite",
        className: "CheckKeyValueHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            },
            lastModified: {
                serializedName: "last-modified",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetLabelsHeaders = {
    serializedName: "getlabels-headers",
    type: {
        name: "Composite",
        className: "GetLabelsHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckLabelsHeaders = {
    serializedName: "checklabels-headers",
    type: {
        name: "Composite",
        className: "CheckLabelsHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const PutLockHeaders = {
    serializedName: "putlock-headers",
    type: {
        name: "Composite",
        className: "PutLockHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DeleteLockHeaders = {
    serializedName: "deletelock-headers",
    type: {
        name: "Composite",
        className: "DeleteLockHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            },
            eTag: {
                serializedName: "etag",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const GetRevisionsHeaders = {
    serializedName: "getrevisions-headers",
    type: {
        name: "Composite",
        className: "GetRevisionsHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const CheckRevisionsHeaders = {
    serializedName: "checkrevisions-headers",
    type: {
        name: "Composite",
        className: "CheckRevisionsHeaders",
        modelProperties: {
            syncToken: {
                serializedName: "sync-token",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Key: Key,
    KeyValue: KeyValue,
    Label: Label,
    ErrorModel: ErrorModel,
    KeyListResult: KeyListResult,
    KeyValueListResult: KeyValueListResult,
    LabelListResult: LabelListResult,
    GetKeysHeaders: GetKeysHeaders,
    CheckKeysHeaders: CheckKeysHeaders,
    GetKeyValuesHeaders: GetKeyValuesHeaders,
    CheckKeyValuesHeaders: CheckKeyValuesHeaders,
    GetKeyValueHeaders: GetKeyValueHeaders,
    PutKeyValueHeaders: PutKeyValueHeaders,
    DeleteKeyValueHeaders: DeleteKeyValueHeaders,
    CheckKeyValueHeaders: CheckKeyValueHeaders,
    GetLabelsHeaders: GetLabelsHeaders,
    CheckLabelsHeaders: CheckLabelsHeaders,
    PutLockHeaders: PutLockHeaders,
    DeleteLockHeaders: DeleteLockHeaders,
    GetRevisionsHeaders: GetRevisionsHeaders,
    CheckRevisionsHeaders: CheckRevisionsHeaders
});

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
const acceptDatetime = {
    parameterPath: [
        "options",
        "acceptDatetime"
    ],
    mapper: {
        serializedName: "Accept-Datetime",
        type: {
            name: "String"
        }
    }
};
const after = {
    parameterPath: [
        "options",
        "after"
    ],
    mapper: {
        serializedName: "After",
        type: {
            name: "String"
        }
    }
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        required: true,
        serializedName: "api-version",
        type: {
            name: "String"
        }
    }
};
const ifMatch = {
    parameterPath: [
        "options",
        "ifMatch"
    ],
    mapper: {
        serializedName: "If-Match",
        type: {
            name: "String"
        }
    }
};
const ifNoneMatch = {
    parameterPath: [
        "options",
        "ifNoneMatch"
    ],
    mapper: {
        serializedName: "If-None-Match",
        type: {
            name: "String"
        }
    }
};
const key0 = {
    parameterPath: [
        "options",
        "key"
    ],
    mapper: {
        serializedName: "key",
        type: {
            name: "String"
        }
    }
};
const key1 = {
    parameterPath: "key",
    mapper: {
        required: true,
        serializedName: "key",
        type: {
            name: "String"
        }
    }
};
const label = {
    parameterPath: [
        "options",
        "label"
    ],
    mapper: {
        serializedName: "label",
        type: {
            name: "String"
        }
    }
};
const name = {
    parameterPath: [
        "options",
        "name"
    ],
    mapper: {
        serializedName: "name",
        type: {
            name: "String"
        }
    }
};
const select = {
    parameterPath: [
        "options",
        "select"
    ],
    mapper: {
        serializedName: "$Select",
        type: {
            name: "Sequence",
            element: {
                type: {
                    name: "String"
                }
            }
        }
    },
    collectionFormat: coreHttp.QueryCollectionFormat.Csv
};
const syncToken = {
    parameterPath: "syncToken",
    mapper: {
        serializedName: "Sync-Token",
        type: {
            name: "String"
        }
    }
};

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
class AppConfigurationContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the AppConfigurationContext class.
     * @param apiVersion The API version to be used with the HTTP request.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param [options] The parameter options
     */
    constructor(credentials, apiVersion, options) {
        if (apiVersion == undefined) {
            throw new Error("'apiVersion' cannot be null.");
        }
        if (credentials == undefined) {
            throw new Error("'credentials' cannot be null.");
        }
        if (!options) {
            options = {};
        }
        super(credentials, options);
        this.baseUri = options.baseUri || this.baseUri || "http://localhost";
        this.requestContentType = "application/json; charset=utf-8";
        this.apiVersion = apiVersion;
        this.credentials = credentials;
        if (options.syncToken !== null && options.syncToken !== undefined) {
            this.syncToken = options.syncToken;
        }
    }
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */
class AppConfiguration extends AppConfigurationContext {
    /**
     * Initializes a new instance of the AppConfiguration class.
     * @param apiVersion The API version to be used with the HTTP request.
     * @param credentials Subscription credentials which uniquely identify client subscription.
     * @param [options] The parameter options
     */
    constructor(credentials, apiVersion, options) {
        super(credentials, apiVersion, options);
    }
    getKeys(options, callback) {
        return this.sendOperationRequest({
            options
        }, getKeysOperationSpec, callback);
    }
    checkKeys(options, callback) {
        return this.sendOperationRequest({
            options
        }, checkKeysOperationSpec, callback);
    }
    getKeyValues(options, callback) {
        return this.sendOperationRequest({
            options
        }, getKeyValuesOperationSpec, callback);
    }
    checkKeyValues(options, callback) {
        return this.sendOperationRequest({
            options
        }, checkKeyValuesOperationSpec, callback);
    }
    getKeyValue(key, options, callback) {
        return this.sendOperationRequest({
            key,
            options
        }, getKeyValueOperationSpec, callback);
    }
    putKeyValue(key, options, callback) {
        return this.sendOperationRequest({
            key,
            options
        }, putKeyValueOperationSpec, callback);
    }
    deleteKeyValue(key, options, callback) {
        return this.sendOperationRequest({
            key,
            options
        }, deleteKeyValueOperationSpec, callback);
    }
    checkKeyValue(key, options, callback) {
        return this.sendOperationRequest({
            key,
            options
        }, checkKeyValueOperationSpec, callback);
    }
    getLabels(options, callback) {
        return this.sendOperationRequest({
            options
        }, getLabelsOperationSpec, callback);
    }
    checkLabels(options, callback) {
        return this.sendOperationRequest({
            options
        }, checkLabelsOperationSpec, callback);
    }
    putLock(key, options, callback) {
        return this.sendOperationRequest({
            key,
            options
        }, putLockOperationSpec, callback);
    }
    deleteLock(key, options, callback) {
        return this.sendOperationRequest({
            key,
            options
        }, deleteLockOperationSpec, callback);
    }
    getRevisions(options, callback) {
        return this.sendOperationRequest({
            options
        }, getRevisionsOperationSpec, callback);
    }
    checkRevisions(options, callback) {
        return this.sendOperationRequest({
            options
        }, checkRevisionsOperationSpec, callback);
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers);
const getKeysOperationSpec = {
    httpMethod: "GET",
    path: "keys",
    queryParameters: [
        name,
        apiVersion,
        after
    ],
    headerParameters: [
        syncToken,
        acceptDatetime
    ],
    responses: {
        200: {
            bodyMapper: KeyListResult,
            headersMapper: GetKeysHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    serializer
};
const checkKeysOperationSpec = {
    httpMethod: "HEAD",
    path: "keys",
    queryParameters: [
        name,
        apiVersion,
        after
    ],
    headerParameters: [
        syncToken,
        acceptDatetime
    ],
    responses: {
        200: {
            headersMapper: CheckKeysHeaders
        },
        default: {}
    },
    serializer
};
const getKeyValuesOperationSpec = {
    httpMethod: "GET",
    path: "kv",
    queryParameters: [
        key0,
        label,
        apiVersion,
        after,
        select
    ],
    headerParameters: [
        syncToken,
        acceptDatetime
    ],
    responses: {
        200: {
            bodyMapper: KeyValueListResult,
            headersMapper: GetKeyValuesHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    serializer
};
const checkKeyValuesOperationSpec = {
    httpMethod: "HEAD",
    path: "kv",
    queryParameters: [
        key0,
        label,
        apiVersion,
        after,
        select
    ],
    headerParameters: [
        syncToken,
        acceptDatetime
    ],
    responses: {
        200: {
            headersMapper: CheckKeyValuesHeaders
        },
        default: {}
    },
    serializer
};
const getKeyValueOperationSpec = {
    httpMethod: "GET",
    path: "kv/{key}",
    urlParameters: [
        key1
    ],
    queryParameters: [
        label,
        apiVersion,
        select
    ],
    headerParameters: [
        syncToken,
        acceptDatetime,
        ifMatch,
        ifNoneMatch
    ],
    responses: {
        200: {
            bodyMapper: KeyValue,
            headersMapper: GetKeyValueHeaders
        },
        304: {
            headersMapper: GetKeyValueHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    serializer
};
const putKeyValueOperationSpec = {
    httpMethod: "PUT",
    path: "kv/{key}",
    urlParameters: [
        key1
    ],
    queryParameters: [
        label,
        apiVersion
    ],
    headerParameters: [
        syncToken,
        ifMatch,
        ifNoneMatch
    ],
    requestBody: {
        parameterPath: [
            "options",
            "entity"
        ],
        mapper: KeyValue
    },
    responses: {
        200: {
            bodyMapper: KeyValue,
            headersMapper: PutKeyValueHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    serializer
};
const deleteKeyValueOperationSpec = {
    httpMethod: "DELETE",
    path: "kv/{key}",
    urlParameters: [
        key1
    ],
    queryParameters: [
        label,
        apiVersion
    ],
    headerParameters: [
        syncToken,
        ifMatch
    ],
    responses: {
        200: {
            bodyMapper: KeyValue,
            headersMapper: DeleteKeyValueHeaders
        },
        204: {
            headersMapper: DeleteKeyValueHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    serializer
};
const checkKeyValueOperationSpec = {
    httpMethod: "HEAD",
    path: "kv/{key}",
    urlParameters: [
        key1
    ],
    queryParameters: [
        label,
        apiVersion,
        select
    ],
    headerParameters: [
        syncToken,
        acceptDatetime,
        ifMatch,
        ifNoneMatch
    ],
    responses: {
        200: {
            headersMapper: CheckKeyValueHeaders
        },
        304: {
            headersMapper: CheckKeyValueHeaders
        },
        default: {}
    },
    serializer
};
const getLabelsOperationSpec = {
    httpMethod: "GET",
    path: "labels",
    queryParameters: [
        name,
        apiVersion,
        after,
        select
    ],
    headerParameters: [
        syncToken,
        acceptDatetime
    ],
    responses: {
        200: {
            bodyMapper: LabelListResult,
            headersMapper: GetLabelsHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    serializer
};
const checkLabelsOperationSpec = {
    httpMethod: "HEAD",
    path: "labels",
    queryParameters: [
        name,
        apiVersion,
        after,
        select
    ],
    headerParameters: [
        syncToken,
        acceptDatetime
    ],
    responses: {
        200: {
            headersMapper: CheckLabelsHeaders
        },
        default: {}
    },
    serializer
};
const putLockOperationSpec = {
    httpMethod: "PUT",
    path: "locks/{key}",
    urlParameters: [
        key1
    ],
    queryParameters: [
        label,
        apiVersion
    ],
    headerParameters: [
        syncToken,
        ifMatch,
        ifNoneMatch
    ],
    responses: {
        200: {
            bodyMapper: KeyValue,
            headersMapper: PutLockHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    serializer
};
const deleteLockOperationSpec = {
    httpMethod: "DELETE",
    path: "locks/{key}",
    urlParameters: [
        key1
    ],
    queryParameters: [
        label,
        apiVersion
    ],
    headerParameters: [
        syncToken,
        ifMatch,
        ifNoneMatch
    ],
    responses: {
        200: {
            bodyMapper: KeyValue,
            headersMapper: DeleteLockHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    serializer
};
const getRevisionsOperationSpec = {
    httpMethod: "GET",
    path: "revisions",
    queryParameters: [
        key0,
        label,
        apiVersion,
        after,
        select
    ],
    headerParameters: [
        syncToken,
        acceptDatetime
    ],
    responses: {
        200: {
            bodyMapper: KeyValueListResult,
            headersMapper: GetRevisionsHeaders
        },
        default: {
            bodyMapper: ErrorModel
        }
    },
    serializer
};
const checkRevisionsOperationSpec = {
    httpMethod: "HEAD",
    path: "revisions",
    queryParameters: [
        key0,
        label,
        apiVersion,
        after,
        select
    ],
    headerParameters: [
        syncToken,
        acceptDatetime
    ],
    responses: {
        200: {
            headersMapper: CheckRevisionsHeaders
        },
        default: {}
    },
    serializer
};

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @ignore
 */
function throttlingRetryPolicy() {
    return {
        create: (nextPolicy, options) => {
            return new ThrottlingRetryPolicy(nextPolicy, options);
        }
    };
}
/**
 * This policy is a close copy of the ThrottlingRetryPolicy class from
 * core-http with modifications to work with how AppConfig is currently
 * responding to 429 responses (which is to throw a RestError).
 *
 * @internal
 * @ignore
 */
class ThrottlingRetryPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options) {
        super(nextPolicy, options);
    }
    sendRequest(httpRequest) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return this._nextPolicy.sendRequest(httpRequest.clone()).catch((err) => {
                if (isRestErrorWithHeaders(err)) {
                    const delayInMs = getDelayInMs(err.response.headers);
                    if (delayInMs == null) {
                        throw err;
                    }
                    return coreHttp.delay(delayInMs).then((_) => this.sendRequest(httpRequest.clone()));
                }
                else {
                    throw err;
                }
            });
        });
    }
    static parseRetryAfterHeader(headerValue) {
        const retryAfterInSeconds = Number(headerValue);
        if (Number.isNaN(retryAfterInSeconds)) {
            return ThrottlingRetryPolicy.parseDateRetryAfterHeader(headerValue);
        }
        else {
            return retryAfterInSeconds * 1000;
        }
    }
    static parseDateRetryAfterHeader(headerValue) {
        try {
            const now = Date.now();
            const date = Date.parse(headerValue);
            const diff = date - now;
            return Number.isNaN(diff) ? undefined : diff;
        }
        catch (error) {
            return undefined;
        }
    }
}
/**
 * The headers that come back from Azure services representing
 * the amount of time (minimum) to wait to retry (in milliseconds).
 */
const RetryAfterMillisecondsHeaders = ["retry-after-ms", "x-ms-retry-after-ms"];
/**
 * Extracts the retry response header, checking against several
 * header names.
 * @internal
 * @ignore
 */
function getDelayInMs(responseHeaders) {
    for (const name of RetryAfterMillisecondsHeaders) {
        const delayValueString = responseHeaders.get(name);
        if (delayValueString == null) {
            continue;
        }
        const delayValueMs = Number(delayValueString);
        if (Number.isNaN(delayValueMs)) {
            return undefined;
        }
        return delayValueMs;
    }
    const retryAfterValue = responseHeaders.get(coreHttp.Constants.HeaderConstants.RETRY_AFTER);
    if (retryAfterValue != null) {
        return ThrottlingRetryPolicy.parseRetryAfterHeader(retryAfterValue);
    }
    return undefined;
}
function isRestErrorWithHeaders(err) {
    return (err &&
        err.statusCode &&
        typeof err.statusCode === "number" &&
        err.response &&
        err.response.headers &&
        typeof err.response.headers.get === "function");
}

// Copyright (c) Microsoft Corporation.
/**
 * Formats the etag so it can be used with a If-Match/If-None-Match header
 * @internal
 * @ignore
 */
function quoteETag(etag) {
    // https://tools.ietf.org/html/rfc7232#section-3.1
    if (etag === undefined || etag === "*") {
        return etag;
    }
    if (etag.startsWith('"') && etag.endsWith('"')) {
        return etag;
    }
    if (etag.startsWith("'") && etag.endsWith("'")) {
        return etag;
    }
    return `"${etag}"`;
}
/**
 * Checks the onlyIfChanged/onlyIfUnchanged properties to make sure we haven't specified both
 * and throws an Error. Otherwise, returns the properties properly quoted.
 * @param options An options object with onlyIfChanged/onlyIfUnchanged fields
 * @internal
 * @ignore
 */
function checkAndFormatIfAndIfNoneMatch(configurationSetting, options) {
    if (options.onlyIfChanged && options.onlyIfUnchanged) {
        throw new Error("onlyIfChanged and onlyIfUnchanged are mutually-exclusive");
    }
    let ifMatch;
    let ifNoneMatch;
    if (options.onlyIfUnchanged) {
        ifMatch = quoteETag(configurationSetting.etag);
    }
    if (options.onlyIfChanged) {
        ifNoneMatch = quoteETag(configurationSetting.etag);
    }
    return {
        ifMatch: ifMatch,
        ifNoneMatch: ifNoneMatch
    };
}
/**
 * Transforms the keys/labels parameters in the listConfigurationSettings and listRevisions
 * into the format the REST call will need.
 *
 * @internal
 * @ignore
 */
function formatWildcards(listConfigOptions) {
    let fieldsToGet;
    if (listConfigOptions.fields) {
        fieldsToGet = listConfigOptions.fields.map((opt) => {
            if (opt === "isReadOnly") {
                return "locked";
            }
            return opt;
        });
    }
    let acceptDatetime = undefined;
    if (listConfigOptions.acceptDateTime) {
        acceptDatetime = listConfigOptions.acceptDateTime.toISOString();
    }
    return {
        key: listConfigOptions.keyFilter,
        label: listConfigOptions.labelFilter,
        acceptDatetime,
        select: fieldsToGet
    };
}
/**
 * Handles translating a Date acceptDateTime into a string as needed by the API
 * @param newOptions A newer style options with acceptDateTime as a date (and with proper casing!)
 * @internal
 * @ignore
 */
function formatAcceptDateTime(newOptions) {
    return {
        acceptDatetime: newOptions.acceptDateTime && newOptions.acceptDateTime.toISOString()
    };
}
/**
 * Take the URL that gets returned from next link and extract the 'after' token needed
 * to get the next page of results.
 * @internal
 * @ignore
 */
function extractAfterTokenFromNextLink(nextLink) {
    let parsedLink = coreHttp.URLBuilder.parse(nextLink);
    let afterToken = parsedLink.getQueryParameterValue("after");
    if (afterToken == null || Array.isArray(afterToken)) {
        throw new Error("Invalid nextLink - invalid after token");
    }
    return decodeURIComponent(afterToken);
}
/**
 * Makes a ConfigurationSetting-based response throw for all of the data members. Used primarily
 * to prevent possible errors by the user in accessing a model that is uninitialized. This can happen
 * in cases like HTTP status code 204 or 304, which return an empty response body.
 *
 * @param configurationSetting The configuration setting to alter
 */
function makeConfigurationSettingEmpty(configurationSetting) {
    const names = [
        "contentType",
        "etag",
        "label",
        "lastModified",
        "isReadOnly",
        "tags",
        "value"
    ];
    for (const name of names) {
        configurationSetting[name] = undefined;
    }
}
/**
 * @ignore
 * @internal
 */
function transformKeyValue(kvp) {
    const obj = Object.assign(Object.assign({}, kvp), { isReadOnly: !!kvp.locked });
    delete obj.locked;
    return obj;
}
/**
 * @ignore
 * @internal
 */
function transformKeyValueResponseWithStatusCode(kvp) {
    return normalizeResponse(kvp, Object.assign(Object.assign({}, transformKeyValue(kvp)), { statusCode: kvp._response.status }));
}
/**
 * @ignore
 * @internal
 */
function transformKeyValueResponse(kvp) {
    return normalizeResponse(kvp, Object.assign({}, transformKeyValue(kvp)));
}
function normalizeResponse(originalResponse, newResponse) {
    Object.defineProperty(newResponse, "_response", {
        enumerable: false,
        value: originalResponse._response
    });
    // this field comes from the header but it's redundant with
    // the one serialized in the model itself
    delete newResponse.eTag;
    return newResponse;
}

// Copyright (c) Microsoft Corporation.
/**
 * @internal
 * @ignore
 */
class Spanner {
    constructor(baseOperationName) {
        this.baseOperationName = baseOperationName;
    }
    /**
     * Traces an operation and properly handles reporting start, end and errors for a given span
     *
     * @param operationName Name of a method in the TClient type
     * @param options An options class, typically derived from @azure/core-http/RequestOptionsBase
     * @param fn The function to call with an options class that properly propagates the span context
     * @param translateToCanonicalCodeFn An optional function to translate thrown errors into a CanonicalCode for the span
     */
    trace(operationName, options, fn, translateToCanonicalCodeFn = Spanner.getCanonicalCode) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { newOptions, span } = this.createSpan(options, operationName);
            try {
                return yield fn(newOptions, span);
            }
            catch (err) {
                span.setStatus({
                    code: translateToCanonicalCodeFn(err),
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    createSpan(options, operationName) {
        const span = coreTracing.getTracer().startSpan(`${this.baseOperationName}.${operationName}`, Object.assign(Object.assign({}, options.spanOptions), { kind: api.SpanKind.INTERNAL }));
        span.setAttribute("az.namespace", "Microsoft.AppConfiguration");
        let newOptions = options;
        if (span.isRecording()) {
            newOptions = Spanner.addParentToOptions(options, span);
        }
        return { span, newOptions };
    }
    static getCanonicalCode(err) {
        if (Spanner.isRestError(err)) {
            switch (err.statusCode) {
                case 401:
                    return api.CanonicalCode.PERMISSION_DENIED;
                case 404:
                    return api.CanonicalCode.NOT_FOUND;
                case 412:
                    return api.CanonicalCode.FAILED_PRECONDITION;
            }
        }
        return api.CanonicalCode.UNKNOWN;
    }
    static isRestError(err) {
        return err instanceof coreHttp.RestError;
    }
    static addParentToOptions(options, span) {
        const spanOptions = options.spanOptions || {};
        return Object.assign(Object.assign({}, options), { spanOptions: Object.assign(Object.assign({}, spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.AppConfiguration" }) }) });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The sync token header, as described here:
 * https://github.com/Azure/AppConfiguration/blob/master/docs/REST/consistency.md
 * @internal
 * @ignore
 */
const SyncTokenHeaderName = "sync-token";
/**
 * A policy factory for injecting sync tokens properly into outgoing requests.
 * @param syncTokens
 * @internal
 * @ignore
 */
function syncTokenPolicy(syncTokens) {
    return {
        create: (nextPolicy, options) => {
            return new SyncTokenPolicy(nextPolicy, options, syncTokens);
        }
    };
}
class SyncTokenPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, _syncTokens) {
        super(nextPolicy, options);
        this._syncTokens = _syncTokens;
    }
    sendRequest(webResource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const syncTokenHeaderValue = this._syncTokens.getSyncTokenHeaderValue();
            if (syncTokenHeaderValue != null) {
                webResource.headers.set(SyncTokenHeaderName, syncTokenHeaderValue);
            }
            const response = yield this._nextPolicy.sendRequest(webResource);
            this._syncTokens.addSyncTokenFromHeaderValue(response.headers.get(SyncTokenHeaderName));
            return response;
        });
    }
}
/**
 * Sync token tracker (allows for real-time consistency, even in the face of
 * caching and load balancing within App Configuration).
 *
 * (protocol and format described here)
 * https://github.com/Azure/AppConfiguration/blob/master/docs/REST/consistency.md
 *
 * @internal
 * @ignore
 */
class SyncTokens {
    constructor() {
        this._currentSyncTokens = new Map();
    }
    /**
     * Takes the value from the header named after the constant `SyncTokenHeaderName`
     * and adds it to our list of accumulated sync tokens.
     *
     * If given an empty value (or undefined) it clears the current list of sync tokens.
     * (indicates the service has properly absorbed values into the cluster).
     *
     * @param syncTokenHeaderValue The full value of the sync token header.
     */
    addSyncTokenFromHeaderValue(syncTokenHeaderValue) {
        if (syncTokenHeaderValue == null || syncTokenHeaderValue === "") {
            // eventually everything gets synced up and we don't have to track
            // these headers anymore
            this._currentSyncTokens.clear();
            return;
        }
        const newTokens = syncTokenHeaderValue.split(",").map(parseSyncToken);
        for (const newToken of newTokens) {
            const existingToken = this._currentSyncTokens.get(newToken.id);
            if (!existingToken || existingToken.sequenceNumber < newToken.sequenceNumber) {
                this._currentSyncTokens.set(newToken.id, newToken);
                continue;
            }
        }
    }
    /**
     * Gets a properly formatted SyncToken header value.
     */
    getSyncTokenHeaderValue() {
        if (this._currentSyncTokens.size === 0) {
            return undefined;
        }
        const syncTokenStrings = [];
        for (const syncToken of this._currentSyncTokens.values()) {
            // note that you don't include the 'sn' field here - that's only
            // used for internal tracking of the 'version' for the token itself
            syncTokenStrings.push(`${syncToken.id}=${syncToken.value}`);
        }
        return syncTokenStrings.join(",");
    }
}
// An example sync token (from their documentation):
//
// jtqGc1I4=MDoyOA==;sn=28
//
// Which breaks down to:
// id: jtqGc1I4
// value: MDoyOA==
// sequence number: 28
const syncTokenRegex = /^([^=]+)=([^;]+);sn=(\d+)$/;
/**
 * Parses a single sync token into it's constituent parts.
 *
 * @param syncToken A single sync token.
 *
 * @internal
 * @ignore
 */
function parseSyncToken(syncToken) {
    const matches = syncToken.match(syncTokenRegex);
    if (matches == null) {
        throw new Error(`Failed to parse sync token '${syncToken}' with regex ${syncTokenRegex.source}`);
    }
    const sequenceNumber = parseInt(matches[3], 10);
    if (isNaN(sequenceNumber)) {
        // this should be impossible since our regex restricts to just digits
        // but there's nothing wrong with being thorough.
        throw new Error(`${syncToken}: The sequence number value '${matches[3]}' wasn't a number`);
    }
    return {
        id: matches[1],
        value: matches[2],
        sequenceNumber
    };
}

// Copyright (c) Microsoft Corporation.
const packageName = "azsdk-js-app-configuration";
/**
 * This constant should always be the same as the package.json's version - we use it when forming the
 * User - Agent header. There's a unit test that makes sure it always stays in sync.
 * @internal
 * @ignore
 */
const packageVersion = "1.1.0";
const apiVersion$1 = "1.0";
const ConnectionStringRegex = /Endpoint=(.*);Id=(.*);Secret=(.*)/;
const deserializationContentTypes = {
    json: [
        "application/vnd.microsoft.appconfig.kvset+json",
        "application/vnd.microsoft.appconfig.kv+json",
        "application/vnd.microsoft.appconfig.kvs+json",
        "application/vnd.microsoft.appconfig.keyset+json",
        "application/vnd.microsoft.appconfig.revs+json"
    ]
};
/**
 * Client for the Azure App Configuration service.
 */
class AppConfigurationClient {
    constructor(connectionStringOrEndpoint, tokenCredentialOrOptions, options) {
        let appConfigOptions = {};
        let appConfigCredential;
        let appConfigEndpoint;
        if (coreHttp.isTokenCredential(tokenCredentialOrOptions)) {
            appConfigOptions = options || {};
            appConfigCredential = tokenCredentialOrOptions;
            appConfigEndpoint = connectionStringOrEndpoint;
        }
        else {
            appConfigOptions = tokenCredentialOrOptions || {};
            const regexMatch = connectionStringOrEndpoint.match(ConnectionStringRegex);
            if (regexMatch) {
                appConfigCredential = new AppConfigCredential(regexMatch[2], regexMatch[3]);
                appConfigEndpoint = regexMatch[1];
            }
            else {
                throw new Error(`Invalid connection string. Valid connection strings should match the regex '${ConnectionStringRegex.source}'.`);
            }
        }
        const syncTokens = appConfigOptions.syncTokens || new SyncTokens();
        this.client = new AppConfiguration(appConfigCredential, apiVersion$1, getGeneratedClientOptions(appConfigEndpoint, syncTokens, appConfigOptions));
        this.spanner = new Spanner("Azure.Data.AppConfiguration");
    }
    /**
     * Add a setting into the Azure App Configuration service, failing if it
     * already exists.
     *
     * Example usage:
     * ```ts
     * const result = await client.addConfigurationSetting({ key: "MyKey", label: "MyLabel", value: "MyValue" });
     * ```
     * @param configurationSetting A configuration setting.
     * @param options Optional parameters for the request.
     */
    addConfigurationSetting(configurationSetting, options = {}) {
        const opts = coreHttp.operationOptionsToRequestOptionsBase(options);
        return this.spanner.trace("addConfigurationSetting", opts, (newOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
            const originalResponse = yield this.client.putKeyValue(configurationSetting.key, Object.assign({ ifNoneMatch: "*", label: configurationSetting.label, entity: configurationSetting }, newOptions));
            return transformKeyValueResponse(originalResponse);
        }));
    }
    /**
     * Delete a setting from the Azure App Configuration service
     *
     * Example usage:
     * ```ts
     * const deletedSetting = await client.deleteConfigurationSetting({ key: "MyKey", label: "MyLabel" });
     * ```
     * @param id The id of the configuration setting to delete.
     * @param options Optional parameters for the request (ex: etag, label)
     */
    deleteConfigurationSetting(id, options = {}) {
        const opts = coreHttp.operationOptionsToRequestOptionsBase(options);
        return this.spanner.trace("deleteConfigurationSetting", opts, (newOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
            const originalResponse = yield this.client.deleteKeyValue(id.key, Object.assign(Object.assign({ label: id.label }, newOptions), checkAndFormatIfAndIfNoneMatch(id, options)));
            return transformKeyValueResponseWithStatusCode(originalResponse);
        }));
    }
    /**
     * Gets a setting from the Azure App Configuration service.
     *
     * Example code:
     * ```ts
     * const setting = await client.getConfigurationSetting({ key: "MyKey", label: "MyLabel" });
     * ```
     * @param id The id of the configuration setting to get.
     * @param options Optional parameters for the request.
     */
    getConfigurationSetting(id, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const opts = coreHttp.operationOptionsToRequestOptionsBase(options);
            return yield this.spanner.trace("getConfigurationSetting", opts, (newOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                const originalResponse = yield this.client.getKeyValue(id.key, Object.assign(Object.assign(Object.assign({ label: id.label, select: newOptions.fields }, newOptions), formatAcceptDateTime(options)), checkAndFormatIfAndIfNoneMatch(id, options)));
                const response = transformKeyValueResponseWithStatusCode(originalResponse);
                // 304 only comes back if the user has passed a conditional option in their
                // request _and_ the remote object has the same etag as what the user passed.
                if (response.statusCode === 304) {
                    // this is one of our few 'required' fields so we'll make sure it does get initialized
                    // with a value
                    response.key = id.key;
                    // and now we'll undefine all the other properties that are not HTTP related
                    makeConfigurationSettingEmpty(response);
                }
                return response;
            }));
        });
    }
    /**
     * Lists settings from the Azure App Configuration service, optionally
     * filtered by key names, labels and accept datetime.
     *
     * Example code:
     * ```ts
     * const allSettingsWithLabel = client.listConfigurationSettings({ labels: [ "MyLabel" ] });
     * ```
     * @param options Optional parameters for the request.
     */
    listConfigurationSettings(options = {}) {
        const iter = this.getListConfigurationSettingsIterator(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (_ = {}) => {
                // The appconfig service doesn't currently support letting you select a page size
                // so we're ignoring their setting for now.
                return this.listConfigurationSettingsByPage(options);
            }
        };
    }
    getListConfigurationSettingsIterator(options) {
        return tslib.__asyncGenerator(this, arguments, function* getListConfigurationSettingsIterator_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listConfigurationSettingsByPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const configurationSetting of page.items) {
                        yield yield tslib.__await(configurationSetting);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listConfigurationSettingsByPage(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listConfigurationSettingsByPage_1() {
            const opts = coreHttp.operationOptionsToRequestOptionsBase(options);
            let currentResponse = yield tslib.__await(this.spanner.trace("listConfigurationSettings", opts, (newOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                const response = yield this.client.getKeyValues(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatWildcards(newOptions)));
                return response;
            })));
            yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(this.createListConfigurationPageFromResponse(currentResponse))));
            while (currentResponse.nextLink) {
                currentResponse = yield tslib.__await(this.spanner.trace("listConfigurationSettings", opts, 
                // TODO: same code up above. Unify.
                (newOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                    const response = yield this.client.getKeyValues(Object.assign(Object.assign(Object.assign({}, newOptions), formatWildcards(newOptions)), { after: extractAfterTokenFromNextLink(currentResponse.nextLink) }));
                    return response;
                })));
                if (!currentResponse.items) {
                    break;
                }
                yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(this.createListConfigurationPageFromResponse(currentResponse))));
            }
        });
    }
    *createListConfigurationPageFromResponse(currentResponse) {
        yield Object.assign(Object.assign({}, currentResponse), { items: currentResponse.items != null ? currentResponse.items.map(transformKeyValue) : [] });
    }
    /**
     * Lists revisions of a set of keys, optionally filtered by key names,
     * labels and accept datetime.
     *
     * Example code:
     * ```ts
     * const revisionsIterator = client.listRevisions({ keys: ["MyKey"] });
     * ```
     * @param options Optional parameters for the request.
     */
    listRevisions(options) {
        const iter = this.getListRevisionsIterator(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (_ = {}) => {
                // The appconfig service doesn't currently support letting you select a page size
                // so we're ignoring their setting for now.
                return this.listRevisionsByPage(options);
            }
        };
    }
    getListRevisionsIterator(options) {
        return tslib.__asyncGenerator(this, arguments, function* getListRevisionsIterator_1() {
            var e_2, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listRevisionsByPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page.items) {
                        yield yield tslib.__await(item);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    listRevisionsByPage(options = {}) {
        return tslib.__asyncGenerator(this, arguments, function* listRevisionsByPage_1() {
            const opts = coreHttp.operationOptionsToRequestOptionsBase(options);
            let currentResponse = yield tslib.__await(this.spanner.trace("listRevisions", opts, (newOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                const response = yield this.client.getRevisions(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatWildcards(newOptions)));
                return response;
            })));
            yield yield tslib.__await(Object.assign(Object.assign({}, currentResponse), { items: currentResponse.items != null ? currentResponse.items.map(transformKeyValue) : [] }));
            while (currentResponse.nextLink) {
                currentResponse = yield tslib.__await(this.spanner.trace("listRevisions", opts, (newOptions) => {
                    return this.client.getRevisions(Object.assign(Object.assign(Object.assign({}, newOptions), formatWildcards(newOptions)), { select: newOptions.fields, after: extractAfterTokenFromNextLink(currentResponse.nextLink) }));
                }));
                if (!currentResponse.items) {
                    break;
                }
                yield yield tslib.__await(Object.assign(Object.assign({}, currentResponse), { items: currentResponse.items != null ? currentResponse.items.map(transformKeyValue) : [] }));
            }
        });
    }
    /**
     * Sets the value of a key in the Azure App Configuration service, allowing for an optional etag.
     * @param key The name of the key.
     * @param configurationSetting A configuration value.
     * @param options Optional parameters for the request.
     *
     * Example code:
     * ```ts
     * await client.setConfigurationSetting({ key: "MyKey", value: "MyValue" });
     * ```
     */
    setConfigurationSetting(configurationSetting, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const opts = coreHttp.operationOptionsToRequestOptionsBase(options);
            return yield this.spanner.trace("setConfigurationSetting", opts, (newOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                const response = yield this.client.putKeyValue(configurationSetting.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: configurationSetting.label, entity: configurationSetting }), checkAndFormatIfAndIfNoneMatch(configurationSetting, options)));
                return transformKeyValueResponse(response);
            }));
        });
    }
    /**
     * Sets or clears a key's read-only status.
     * @param id The id of the configuration setting to modify.
     */
    setReadOnly(id, readOnly, options = {}) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const opts = coreHttp.operationOptionsToRequestOptionsBase(options);
            return this.spanner.trace("setReadOnly", opts, (newOptions) => tslib.__awaiter(this, void 0, void 0, function* () {
                if (readOnly) {
                    const response = yield this.client.putLock(id.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: id.label }), checkAndFormatIfAndIfNoneMatch(id, options)));
                    return transformKeyValueResponse(response);
                }
                else {
                    const response = yield this.client.deleteLock(id.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: id.label }), checkAndFormatIfAndIfNoneMatch(id, options)));
                    return transformKeyValueResponse(response);
                }
            }));
        });
    }
}
/**
 * Gets the options for the generated AppConfigurationClient
 * @internal
 * @ignore
 */
function getGeneratedClientOptions(baseUri, syncTokens, internalAppConfigOptions) {
    const retryPolicies = [
        coreHttp.exponentialRetryPolicy(),
        coreHttp.systemErrorRetryPolicy(),
        throttlingRetryPolicy()
    ];
    const userAgent = getUserAgentPrefix(internalAppConfigOptions.userAgentOptions &&
        internalAppConfigOptions.userAgentOptions.userAgentPrefix);
    return {
        baseUri,
        deserializationContentTypes,
        // we'll add in our own custom retry policies
        noRetryPolicy: true,
        requestPolicyFactories: (defaults) => [
            coreHttp.tracingPolicy({ userAgent }),
            syncTokenPolicy(syncTokens),
            coreHttp.userAgentPolicy({ value: userAgent }),
            ...retryPolicies,
            ...defaults
        ],
        generateClientRequestIdHeader: true
    };
}
/**
 * @internal
 * @ignore
 */
function getUserAgentPrefix(userSuppliedUserAgent) {
    const appConfigDefaultUserAgent = `${packageName}/${packageVersion} ${coreHttp.getDefaultUserAgentValue()}`;
    if (!userSuppliedUserAgent) {
        return appConfigDefaultUserAgent;
    }
    return `${userSuppliedUserAgent} ${appConfigDefaultUserAgent}`;
}

exports.AppConfigurationClient = AppConfigurationClient;
//# sourceMappingURL=index.js.map
