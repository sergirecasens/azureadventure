// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
import { __awaiter } from "tslib";
import * as assert from "assert";
import { createAppConfigurationClientForTests, deleteKeyCompletely, toSortedArray, assertEqualSettings, assertThrowsRestError, assertThrowsAbortError, startRecorder } from "./testHelpers";
import { delay } from "@azure/core-http";
describe("AppConfigurationClient", () => {
    let client;
    let recorder;
    beforeEach(function () {
        recorder = startRecorder(this);
        client = createAppConfigurationClientForTests() || this.skip();
    });
    afterEach(function () {
        recorder.stop();
    });
    describe("simple usages", () => {
        it("Add and query a setting without a label", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("noLabelTests");
            yield client.addConfigurationSetting({ key, value: "added" });
            yield compare({
                key,
                value: "added",
                label: undefined
            });
            yield client.deleteConfigurationSetting({ key });
            // will recreate the setting
            yield client.setConfigurationSetting({ key, value: "set" });
            yield compare({
                key,
                value: "set",
                label: undefined
            });
            // and now acts as a wholesale update
            yield client.setConfigurationSetting({ key, value: "set a second time" });
            yield compare({
                key,
                value: "set a second time",
                label: undefined
            });
            yield client.deleteConfigurationSetting({ key });
        }));
        function compare(expected) {
            return __awaiter(this, void 0, void 0, function* () {
                const actualSettings = yield client.getConfigurationSetting(expected);
                assert.equal(expected.key, actualSettings.key);
                assert.equal(expected.value, actualSettings.value);
                assert.equal(expected.label, actualSettings.label);
            });
        }
    });
    describe("addConfigurationSetting", () => {
        it("sample works", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("addConfigSample");
            const result = yield client.setConfigurationSetting({
                key,
                value: "MyValue"
            });
            assert.equal(key, result.key);
        }));
        it("adds a configuration setting", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("addConfigTest");
            const label = "MyLabel";
            const value = "MyValue";
            const result = yield client.addConfigurationSetting({ key, label, value });
            assert.equal(result.key, key, "Unexpected key in result from addConfigurationSetting().");
            assert.equal(result.label, label, "Unexpected label in result from addConfigurationSetting().");
            assert.equal(result.value, value, "Unexpected value in result from addConfigurationSetting().");
            // just a sanity check - the 'eTag' field that gets added by the response headers
            // is removed (and is replaced by the 'etag' field in the model)
            assert.ok(!result.eTag);
            assert.ok(result.etag);
            yield client.deleteConfigurationSetting({ key, label });
        }));
        it("throws an error if the configuration setting already exists", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("addConfigTestTwice");
            const label = "test";
            const value = "foo";
            const result = yield client.addConfigurationSetting({ key, label, value });
            assert.equal(result.key, key, "Unexpected key in result from addConfigurationSetting().");
            assert.equal(result.label, label, "Unexpected label in result from addConfigurationSetting().");
            assert.equal(result.value, value, "Unexpected value in result from addConfigurationSetting().");
            // attempt to add the same setting
            try {
                yield client.addConfigurationSetting({ key, label, value });
                throw new Error("Test failure");
            }
            catch (err) {
                assert.notEqual(err.message, "Test failure");
            }
            yield client.deleteConfigurationSetting({ key, label });
        }));
        it("accepts operation options", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("addConfigTestTwice");
            const label = "test";
            const value = "foo";
            yield assertThrowsAbortError(() => __awaiter(void 0, void 0, void 0, function* () {
                yield client.addConfigurationSetting({ key, label, value }, {
                    requestOptions: {
                        timeout: 1
                    }
                });
            }));
        }));
    });
    describe("deleteConfigurationSetting", () => {
        it("deletes an existing configuration setting", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("deleteConfigTest");
            const label = "MyLabel";
            const value = "MyValue";
            // create configuration
            const result = yield client.addConfigurationSetting({ key, label, value });
            assert.equal(result.key, key, "Unexpected key in result from addConfigurationSetting().");
            assert.equal(result.label, label, "Unexpected label in result from addConfigurationSetting().");
            assert.equal(result.value, value, "Unexpected value in result from addConfigurationSetting().");
            // delete configuration
            const deletedSetting = yield client.deleteConfigurationSetting(result);
            assert.equal(200, deletedSetting._response.status);
            // confirm setting no longer exists
            try {
                yield client.getConfigurationSetting({ key, label });
                throw new Error("Test failure");
            }
            catch (err) {
                assert.notEqual(err.message, "Test failure");
            }
        }));
        it("deletes an existing configuration setting (valid etag)", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("deleteConfigTestEtag");
            const label = "test";
            const value = "foo";
            // create configuration
            const result = yield client.addConfigurationSetting({ key, label, value });
            assert.equal(result.key, key, "Unexpected key in result from addConfigurationSetting().");
            assert.equal(result.label, label, "Unexpected label in result from addConfigurationSetting().");
            assert.equal(result.value, value, "Unexpected value in result from addConfigurationSetting().");
            // delete configuration
            yield client.deleteConfigurationSetting({
                key,
                label
            }, { onlyIfUnchanged: true });
            // confirm setting no longer exists
            try {
                yield client.getConfigurationSetting({ key, label });
                throw new Error("Test failure");
            }
            catch (err) {
                assert.notEqual(err.message, "Test failure");
            }
        }));
        it("does not throw when deleting a non-existent configuration setting", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("deleteConfigTestNA");
            const label = "test";
            // delete configuration
            const response = yield client.deleteConfigurationSetting({ key, label });
            // we hoist this code up to the top in case users want to check if the
            // delete actually happened (status code: 200) or if the setting wasn't
            // found which results in the same state but might matter to
            // the user(status code: 204)
            assert.equal(response._response.status, response.statusCode);
            assert.equal(204, response.statusCode);
        }));
        it("throws when deleting a configuration setting (invalid etag)", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("deleteConfigTestBadEtag");
            const label = "test";
            const value = "foo";
            // create configuration
            const result = yield client.addConfigurationSetting({ key, label, value });
            assert.equal(result.key, key, "Unexpected key in result from addConfigurationSetting().");
            assert.equal(result.label, label, "Unexpected label in result from addConfigurationSetting().");
            assert.equal(result.value, value, "Unexpected value in result from addConfigurationSetting().");
            // delete configuration
            yield assertThrowsRestError(() => client.deleteConfigurationSetting({ key, label, etag: "invalid" }, { onlyIfUnchanged: true }), 412);
            yield client.deleteConfigurationSetting({ key, label });
        }));
        it("accepts operation options", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("deleteConfigTest");
            const label = "MyLabel";
            const value = "MyValue";
            // create configuration
            const result = yield client.addConfigurationSetting({ key, label, value });
            // delete configuration
            yield assertThrowsAbortError(() => __awaiter(void 0, void 0, void 0, function* () {
                yield client.deleteConfigurationSetting(result, {
                    requestOptions: { timeout: 1 }
                });
            }));
        }));
    });
    describe("getConfigurationSetting", () => {
        it("retrieves an existing configuration setting", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("getConfigTest");
            const label = "test";
            const value = "foo";
            const tags = {
                bar: "baz",
                car: "caz"
            };
            const contentType = "application/json";
            // create configuration
            const result = yield client.addConfigurationSetting({ key, label, value, contentType, tags });
            assert.equal(result.key, key, "Unexpected key in result from addConfigurationSetting().");
            assert.equal(result.label, label, "Unexpected label in result from addConfigurationSetting().");
            assert.equal(result.value, value, "Unexpected value in result from addConfigurationSetting().");
            assert.equal(result.lastModified instanceof Date, true, "Unexpected lastModified in result from addConfigurationSetting().");
            assert.equal(result.isReadOnly, false, "Unexpected readOnly in result from addConfigurationSetting().");
            assert.deepEqual(result.tags, tags, "Unexpected tags in result from addConfigurationSetting().");
            assert.equal(result.contentType, contentType, "Unexpected contentType in result from addConfigurationSetting().");
            // retrieve the value from the service
            const remoteResult = yield client.getConfigurationSetting({ key, label });
            assert.equal(remoteResult.key, key, "Unexpected key in result from getConfigurationSetting().");
            assert.equal(remoteResult.label, label, "Unexpected label in result from getConfigurationSetting().");
            assert.equal(remoteResult.value, value, "Unexpected value in result from getConfigurationSetting().");
            assert.equal(remoteResult.lastModified instanceof Date, true, "Unexpected lastModified in result from getConfigurationSetting().");
            assert.equal(remoteResult.isReadOnly, false, "Unexpected readOnly in result from getConfigurationSetting().");
            assert.deepEqual(remoteResult.tags, tags, "Unexpected tags in result from getConfigurationSetting().");
            assert.equal(remoteResult.contentType, contentType, "Unexpected contentType in result from getConfigurationSetting().");
            yield client.deleteConfigurationSetting({ key, label });
        }));
        it("throws when retrieving a non-existent configuration setting", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("getConfigTestNA");
            const label = "test";
            // retrieve the value from the service
            try {
                yield client.getConfigurationSetting({ key, label });
                throw new Error("Test failure");
            }
            catch (err) {
                assert.notEqual(err.message, "Test failure");
            }
        }));
        it("accepts operation options", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("getConfigTest");
            const label = "test";
            const value = "foo";
            const tags = {
                bar: "baz",
                car: "caz"
            };
            const contentType = "application/json";
            yield client.addConfigurationSetting({ key, label, value, contentType, tags });
            yield assertThrowsAbortError(() => __awaiter(void 0, void 0, void 0, function* () {
                yield client.getConfigurationSetting({ key, label }, { requestOptions: { timeout: 1 } });
            }));
        }));
        it("by date", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("getConfigurationSettingByDate");
            const initialSetting = yield client.setConfigurationSetting({
                key,
                value: "value1"
            });
            yield delay(1000);
            yield client.setConfigurationSetting({
                key,
                value: "value2"
            });
            const settingAtPointInTime = yield client.getConfigurationSetting({ key }, {
                acceptDateTime: initialSetting.lastModified
            });
            assert.equal("value1", settingAtPointInTime.value);
        }));
    });
    describe("listConfigurationSettings", () => {
        let uniqueLabel;
        let listConfigSettingA;
        let count = 0;
        let productionASettingId = {
            key: "",
            label: "",
            value: "[A] production value"
        };
        let keys = {
            listConfigSettingA: "",
            listConfigSettingB: ""
        };
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            keys.listConfigSettingA = recorder.getUniqueName(`listConfigSetting${count}A`);
            keys.listConfigSettingB = recorder.getUniqueName(`listConfigSetting${count}B`);
            count += 1;
            uniqueLabel = recorder.getUniqueName("listConfigSettingsLabel");
            productionASettingId.key = keys.listConfigSettingA;
            productionASettingId.label = uniqueLabel;
            yield client.addConfigurationSetting(productionASettingId);
            yield client.setReadOnly(productionASettingId, true);
            listConfigSettingA = yield client.addConfigurationSetting({
                key: keys.listConfigSettingA,
                value: "[A] value"
            });
            yield client.addConfigurationSetting({
                key: keys.listConfigSettingB,
                label: uniqueLabel,
                value: "[B] production value"
            });
            yield client.addConfigurationSetting({
                key: keys.listConfigSettingB,
                value: "[B] value"
            });
        }));
        after(() => __awaiter(void 0, void 0, void 0, function* () {
            try {
                yield deleteKeyCompletely([keys.listConfigSettingA, keys.listConfigSettingB], client);
            }
            catch (e) { }
        }));
        it("undefined doesn't throw and will just return everything", () => __awaiter(void 0, void 0, void 0, function* () {
            const settingsIterator = client.listConfigurationSettings();
            yield settingsIterator.next();
        }));
        it("exact match on label", () => __awaiter(void 0, void 0, void 0, function* () {
            // query with a direct label match
            let byLabelIterator = client.listConfigurationSettings({ labelFilter: uniqueLabel });
            const byLabelSettings = yield toSortedArray(byLabelIterator);
            assertEqualSettings([
                {
                    key: keys.listConfigSettingA,
                    value: "[A] production value",
                    label: uniqueLabel,
                    isReadOnly: true
                },
                {
                    key: keys.listConfigSettingB,
                    value: "[B] production value",
                    label: uniqueLabel,
                    isReadOnly: false
                }
            ], byLabelSettings);
        }));
        it("label wildcards", () => __awaiter(void 0, void 0, void 0, function* () {
            // query with a direct label match
            let byLabelIterator = client.listConfigurationSettings({
                labelFilter: uniqueLabel.substring(0, uniqueLabel.length - 1) + "*"
            });
            const byLabelSettings = yield toSortedArray(byLabelIterator);
            assertEqualSettings([
                {
                    key: keys.listConfigSettingA,
                    value: "[A] production value",
                    label: uniqueLabel,
                    isReadOnly: true
                },
                {
                    key: keys.listConfigSettingB,
                    value: "[B] production value",
                    label: uniqueLabel,
                    isReadOnly: false
                }
            ], byLabelSettings);
        }));
        it("exact match on key", () => __awaiter(void 0, void 0, void 0, function* () {
            let byKeyIterator = client.listConfigurationSettings({
                keyFilter: keys.listConfigSettingA
            });
            const byKeySettings = yield toSortedArray(byKeyIterator);
            assertEqualSettings([
                {
                    key: keys.listConfigSettingA,
                    value: "[A] production value",
                    label: uniqueLabel,
                    isReadOnly: true
                },
                {
                    key: keys.listConfigSettingA,
                    value: "[A] value",
                    label: undefined,
                    isReadOnly: false
                }
            ], byKeySettings);
        }));
        it("key wildcards", () => __awaiter(void 0, void 0, void 0, function* () {
            // query with a key wildcard
            const keyFilter = keys.listConfigSettingA;
            let byKeyIterator = client.listConfigurationSettings({
                keyFilter: keyFilter.substring(0, keyFilter.length - 1) + "*"
            });
            const byKeySettings = yield toSortedArray(byKeyIterator);
            assertEqualSettings([
                {
                    key: keys.listConfigSettingA,
                    value: "[A] production value",
                    label: uniqueLabel,
                    isReadOnly: true
                },
                {
                    key: keys.listConfigSettingA,
                    value: "[A] value",
                    label: undefined,
                    isReadOnly: false
                }
            ], byKeySettings);
        }));
        it("filter on fields", () => __awaiter(void 0, void 0, void 0, function* () {
            // only fill in the 'readOnly' field (which is really the locked field in the REST model)
            let byKeyIterator = client.listConfigurationSettings({
                keyFilter: keys.listConfigSettingA,
                fields: ["key", "label", "isReadOnly"]
            });
            let settings = yield toSortedArray(byKeyIterator);
            // the fields we retrieved
            assert.equal(productionASettingId.key, settings[0].key);
            assert.ok(settings[0].isReadOnly);
            assert.equal(uniqueLabel, settings[0].label);
            assert.ok(!settings[0].contentType);
            assert.ok(!settings[0].value);
            assert.ok(!settings[0].etag);
            // only fill in the 'readOnly' field (which is really the locked field in the REST model)
            byKeyIterator = client.listConfigurationSettings({
                keyFilter: keys.listConfigSettingA,
                fields: ["key", "label", "value"]
            });
            settings = yield toSortedArray(byKeyIterator);
            // the fields we retrieved
            assert.equal(productionASettingId.key, settings[0].key);
            assert.equal("[A] production value", settings[0].value);
            assert.equal(uniqueLabel, settings[0].label);
            assert.ok(!settings[0].isReadOnly);
            assert.ok(!settings[0].contentType);
            assert.ok(!settings[0].etag);
        }));
        it("by date", () => __awaiter(void 0, void 0, void 0, function* () {
            let byKeyIterator = client.listConfigurationSettings({
                keyFilter: "listConfigSetting*",
                acceptDateTime: listConfigSettingA.lastModified
            });
            let settings = yield toSortedArray(byKeyIterator);
            let foundMyExactSettingToo = false;
            // all settings returned should be the same date or as old as my setting
            for (const setting of settings) {
                assert.ok(setting.lastModified);
                assert.ok(setting.lastModified <= listConfigSettingA.lastModified);
                if (setting.key === listConfigSettingA.key && setting.label === listConfigSettingA.label) {
                    foundMyExactSettingToo = true;
                }
            }
            assert.ok(foundMyExactSettingToo);
        }));
        it("list with multiple pages", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName("listMultiplePagesOfResults");
            // this number is arbitrarily chosen to match the size of a page + 1
            const expectedNumberOfLabels = 200;
            let addSettingPromises = [];
            for (let i = 0; i < expectedNumberOfLabels; i++) {
                addSettingPromises.push(client.addConfigurationSetting({
                    key,
                    value: `the value for ${i}`,
                    label: i.toString()
                }));
                if (i !== 0 && i % 10 === 0) {
                    yield Promise.all(addSettingPromises);
                    addSettingPromises = [];
                }
            }
            yield Promise.all(addSettingPromises);
            let listResult = client.listConfigurationSettings({
                keyFilter: key
            });
            const sortedResults = yield toSortedArray(listResult);
            assert.equal(sortedResults.length, 200);
            // make sure we have 200 unique labels
            const uniqueLabels = new Set(sortedResults.map((res) => res.label));
            assert.equal(uniqueLabels.size, 200);
            for (let i = 0; i < 200; ++i) {
                assert.ok(uniqueLabels.has(i.toString()));
            }
            for (let i = 0; i < expectedNumberOfLabels; i++) {
                yield client.deleteConfigurationSetting({ key, label: i.toString() });
            }
        }));
        it("accepts operation options", () => __awaiter(void 0, void 0, void 0, function* () {
            yield assertThrowsAbortError(() => __awaiter(void 0, void 0, void 0, function* () {
                const settingsIterator = client.listConfigurationSettings({
                    requestOptions: { timeout: 1 }
                });
                yield settingsIterator.next();
            }));
        }));
    });
    describe("listRevisions", () => {
        let key;
        let labelA;
        let labelB;
        let originalSetting;
        beforeEach(() => __awaiter(void 0, void 0, void 0, function* () {
            key = recorder.getUniqueName(`listRevisions`);
            labelA = recorder.getUniqueName(`list-revisions-A`);
            labelB = recorder.getUniqueName(`list-revisions-B`);
            // we'll generate two sets of keys and labels for this selection
            originalSetting = yield client.addConfigurationSetting({
                key,
                label: labelA,
                value: "fooA1"
            });
            yield delay(1000);
            yield client.setConfigurationSetting({ key, label: labelA, value: "fooA2" });
            yield client.addConfigurationSetting({ key, label: labelB, value: "fooB1" });
            yield client.setConfigurationSetting({ key, label: labelB, value: "fooB2" });
        }));
        it("exact match on label", () => __awaiter(void 0, void 0, void 0, function* () {
            const revisionsWithLabelIterator = client.listRevisions({ labelFilter: labelA });
            const revisions = yield toSortedArray(revisionsWithLabelIterator);
            assertEqualSettings([
                { key, label: labelA, value: "fooA1", isReadOnly: false },
                { key, label: labelA, value: "fooA2", isReadOnly: false }
            ], revisions);
        }));
        it("label wildcards", () => __awaiter(void 0, void 0, void 0, function* () {
            const revisionsWithLabelIterator = client.listRevisions({
                labelFilter: labelA.substring(0, labelA.length - 1) + "*"
            });
            const revisions = yield toSortedArray(revisionsWithLabelIterator);
            assertEqualSettings([
                { key, label: labelA, value: "fooA1", isReadOnly: false },
                { key, label: labelA, value: "fooA2", isReadOnly: false }
            ], revisions);
        }));
        it("exact match on key", () => __awaiter(void 0, void 0, void 0, function* () {
            const revisionsWithKeyIterator = client.listRevisions({ keyFilter: key });
            const revisions = yield toSortedArray(revisionsWithKeyIterator);
            assertEqualSettings([
                { key, label: labelA, value: "fooA1", isReadOnly: false },
                { key, label: labelA, value: "fooA2", isReadOnly: false },
                { key, label: labelB, value: "fooB1", isReadOnly: false },
                { key, label: labelB, value: "fooB2", isReadOnly: false }
            ], revisions);
        }));
        it("key wildcards", () => __awaiter(void 0, void 0, void 0, function* () {
            const revisionsWithKeyIterator = client.listRevisions({
                keyFilter: key.substring(0, key.length - 1) + "*"
            });
            const revisions = yield toSortedArray(revisionsWithKeyIterator);
            assertEqualSettings([
                { key, label: labelA, value: "fooA1", isReadOnly: false },
                { key, label: labelA, value: "fooA2", isReadOnly: false },
                { key, label: labelB, value: "fooB1", isReadOnly: false },
                { key, label: labelB, value: "fooB2", isReadOnly: false }
            ], revisions);
        }));
        it("accepts operation options", () => __awaiter(void 0, void 0, void 0, function* () {
            yield assertThrowsAbortError(() => __awaiter(void 0, void 0, void 0, function* () {
                const iter = client.listRevisions({ labelFilter: labelA, requestOptions: { timeout: 1 } });
                yield iter.next();
            }));
        }));
        it("by date", () => __awaiter(void 0, void 0, void 0, function* () {
            let byKeyIterator = client.listRevisions({
                keyFilter: key,
                acceptDateTime: originalSetting.lastModified
            });
            let settings = yield toSortedArray(byKeyIterator);
            assert.deepEqual({
                key: originalSetting.key,
                label: originalSetting.label,
                value: originalSetting.value,
                isReadOnly: originalSetting.isReadOnly
            }, {
                key: settings[0].key,
                label: settings[0].label,
                value: settings[0].value,
                isReadOnly: settings[0].isReadOnly
            });
        }));
    });
    describe("setConfigurationSetting", () => {
        it("replaces a configuration setting", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName(`setConfigTest`);
            const label = "test";
            const contentType = "application/json";
            const tags = {
                bar: "baz",
                car: "caz"
            };
            // create configuration
            const result = yield client.addConfigurationSetting({
                key,
                label,
                value: "foo",
                contentType,
                tags
            });
            assert.equal(result.key, key, "Unexpected key in result from addConfigurationSetting().");
            assert.equal(result.label, label, "Unexpected label in result from addConfigurationSetting().");
            assert.equal(result.value, "foo", "Unexpected value in result from addConfigurationSetting().");
            assert.equal(result.lastModified instanceof Date, true, "Unexpected lastModified in result from addConfigurationSetting().");
            assert.equal(result.isReadOnly, false, "Unexpected readOnly in result from addConfigurationSetting().");
            assert.deepEqual(result.tags, tags, "Unexpected tags in result from addConfigurationSetting().");
            assert.equal(result.contentType, contentType, "Unexpected contentType in result from addConfigurationSetting().");
            const replacedResult = yield client.setConfigurationSetting({ key, label, value: "foo2" });
            assert.equal(replacedResult.key, key, "Unexpected key in result from setConfigurationSetting().");
            assert.equal(replacedResult.label, label, "Unexpected label in result from setConfigurationSetting().");
            assert.equal(replacedResult.value, "foo2", "Unexpected value in result from setConfigurationSetting().");
            assert.equal(replacedResult.lastModified instanceof Date, true, "Unexpected lastModified in result from setConfigurationSetting().");
            assert.equal(replacedResult.isReadOnly, false, "Unexpected readOnly in result from setConfigurationSetting().");
            assert.deepEqual(replacedResult.tags, {}, "Unexpected tags in result from setConfigurationSetting().");
            assert.strictEqual(replacedResult.contentType, null, "Unexpected contentType in result from setConfigurationSetting().");
            yield client.deleteConfigurationSetting({ key, label });
        }));
        it("replaces a configuration setting (valid etag)", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName(`setConfigTestEtag`);
            const label = "test";
            const contentType = "application/json";
            const tags = {
                bar: "baz",
                car: "caz"
            };
            // create configuration
            const result = yield client.addConfigurationSetting({
                key,
                label,
                value: "foo",
                contentType,
                tags
            });
            assert.equal(result.key, key, "Unexpected key in result from addConfigurationSetting().");
            assert.equal(result.label, label, "Unexpected label in result from addConfigurationSetting().");
            assert.equal(result.value, "foo", "Unexpected value in result from addConfigurationSetting().");
            assert.equal(result.lastModified instanceof Date, true, "Unexpected lastModified in result from addConfigurationSetting().");
            assert.equal(result.isReadOnly, false, "Unexpected readOnly in result from addConfigurationSetting().");
            assert.deepEqual(result.tags, tags, "Unexpected tags in result from addConfigurationSetting().");
            assert.equal(result.contentType, contentType, "Unexpected contentType in result from addConfigurationSetting().");
            const replacedResult = yield client.setConfigurationSetting({
                key,
                label,
                value: "foo2",
                etag: result.etag
            }, { onlyIfUnchanged: true });
            assert.equal(replacedResult.key, key, "Unexpected key in result from setConfigurationSetting().");
            assert.equal(replacedResult.label, label, "Unexpected label in result from setConfigurationSetting().");
            assert.equal(replacedResult.value, "foo2", "Unexpected value in result from setConfigurationSetting().");
            assert.equal(replacedResult.lastModified instanceof Date, true, "Unexpected lastModified in result from setConfigurationSetting().");
            assert.equal(replacedResult.isReadOnly, false, "Unexpected readOnly in result from setConfigurationSetting().");
            assert.deepEqual(replacedResult.tags, {}, "Unexpected tags in result from setConfigurationSetting().");
            assert.strictEqual(replacedResult.contentType, null, "Unexpected contentType in result from setConfigurationSetting().");
            yield client.deleteConfigurationSetting({ key, label });
        }));
        it("creates a configuration setting if it doesn't exist", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName(`setConfigTestNA`);
            const label = "test";
            const value = "foo";
            const result = yield client.setConfigurationSetting({ key, label, value: "foo" });
            assert.equal(result.key, key, "Unexpected key in result from setConfigurationSetting().");
            assert.equal(result.label, label, "Unexpected label in result from setConfigurationSetting().");
            assert.equal(result.value, value, "Unexpected value in result from setConfigurationSetting().");
            assert.equal(result.lastModified instanceof Date, true, "Unexpected lastModified in result from setConfigurationSetting().");
            assert.equal(result.isReadOnly, false, "Unexpected readOnly in result from setConfigurationSetting().");
            assert.deepEqual(result.tags, {}, "Unexpected tags in result from setConfigurationSetting().");
            assert.strictEqual(result.contentType, null, "Unexpected contentType in result from setConfigurationSetting().");
        }));
        it("accepts operation options", () => __awaiter(void 0, void 0, void 0, function* () {
            const key = recorder.getUniqueName(`setConfigTestNA`);
            const label = "test";
            const value = "foo";
            yield assertThrowsAbortError(() => __awaiter(void 0, void 0, void 0, function* () {
                yield client.setConfigurationSetting({ key, label, value: value }, {
                    requestOptions: {
                        timeout: 1
                    }
                });
            }));
        }));
    });
});
//# sourceMappingURL=index.spec.js.map