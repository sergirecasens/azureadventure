// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncValues, __awaiter } from "tslib";
import { AppConfigurationClient } from "../src";
import { env, isPlaybackMode, record } from "@azure/test-utils-recorder";
import * as assert from "assert";
// allow loading from a .env file as an alternative to defining the variable
// in the environment
import * as dotenv from "dotenv";
import { RestError } from "@azure/core-http";
import { DefaultAzureCredential } from "@azure/identity";
dotenv.config();
let connectionStringNotPresentWarning = false;
let tokenCredentialsNotPresentWarning = false;
export function startRecorder(that) {
    const recorderEnvSetup = {
        replaceableVariables: {
            AZ_CONFIG_CONNECTION: "Endpoint=https://myappconfig.azconfig.io;Id=123456;Secret=123456",
            AZ_CONFIG_ENDPOINT: "https://myappconfig.azconfig.io",
            AZURE_CLIENT_ID: "azure_client_id",
            AZURE_CLIENT_SECRET: "azure_client_secret",
            AZURE_TENANT_ID: "azure_tenant_id"
        },
        customizationsOnRecordings: [
            (recording) => recording.replace(/"access_token":"[^"]*"/g, `"access_token":"access_token"`)
        ],
        queryParametersToSkip: []
    };
    return record(that, recorderEnvSetup);
}
export function getTokenAuthenticationCredential() {
    const requiredEnvironmentVariables = [
        "AZ_CONFIG_ENDPOINT",
        "AZURE_CLIENT_ID",
        "AZURE_TENANT_ID",
        "AZURE_CLIENT_SECRET"
    ];
    for (const name of requiredEnvironmentVariables) {
        const value = env[name];
        if (value == null) {
            if (tokenCredentialsNotPresentWarning) {
                tokenCredentialsNotPresentWarning = true;
                console.log("Functional tests not running - set client identity variables to activate");
            }
            return undefined;
        }
    }
    return {
        credential: new DefaultAzureCredential(),
        endpoint: env["AZ_CONFIG_ENDPOINT"]
    };
}
export function createAppConfigurationClientForTests(options) {
    const connectionString = env["AZ_CONFIG_CONNECTION"];
    if (connectionString == null) {
        if (!connectionStringNotPresentWarning) {
            connectionStringNotPresentWarning = true;
            console.log("Functional tests not running - set AZ_CONFIG_CONNECTION to a valid AppConfig connection string to activate");
        }
        return undefined;
    }
    return new AppConfigurationClient(connectionString, options);
}
export function deleteKeyCompletely(keys, client) {
    var e_1, _a;
    return __awaiter(this, void 0, void 0, function* () {
        const settingsIterator = client.listConfigurationSettings({
            keyFilter: keys.join(",")
        });
        try {
            for (var settingsIterator_1 = __asyncValues(settingsIterator), settingsIterator_1_1; settingsIterator_1_1 = yield settingsIterator_1.next(), !settingsIterator_1_1.done;) {
                const setting = settingsIterator_1_1.value;
                if (setting.isReadOnly) {
                    yield client.setReadOnly(setting, false);
                }
                yield client.deleteConfigurationSetting({ key: setting.key, label: setting.label });
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (settingsIterator_1_1 && !settingsIterator_1_1.done && (_a = settingsIterator_1.return)) yield _a.call(settingsIterator_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    });
}
export function toSortedArray(pagedIterator, compareFn) {
    var pagedIterator_1, pagedIterator_1_1;
    var e_2, _a, e_3, _b;
    return __awaiter(this, void 0, void 0, function* () {
        const settings = [];
        try {
            for (pagedIterator_1 = __asyncValues(pagedIterator); pagedIterator_1_1 = yield pagedIterator_1.next(), !pagedIterator_1_1.done;) {
                const setting = pagedIterator_1_1.value;
                settings.push(setting);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (pagedIterator_1_1 && !pagedIterator_1_1.done && (_a = pagedIterator_1.return)) yield _a.call(pagedIterator_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        let settingsViaPageIterator = [];
        try {
            for (var _c = __asyncValues(pagedIterator.byPage()), _d; _d = yield _c.next(), !_d.done;) {
                const page = _d.value;
                settingsViaPageIterator = settingsViaPageIterator.concat(page.items);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_b = _c.return)) yield _b.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        // just a sanity-check
        assert.deepEqual(settings, settingsViaPageIterator);
        settings.sort((a, b) => compareFn
            ? compareFn(a, b)
            : `${a.key}-${a.label}-${a.value}`.localeCompare(`${b.key}-${b.label}-${b.value}`));
        return settings;
    });
}
export function assertEqualSettings(expected, actual) {
    actual = actual.map((setting) => {
        return {
            key: setting.key,
            label: setting.label,
            value: setting.value,
            isReadOnly: setting.isReadOnly
        };
    });
    assert.deepEqual(expected, actual);
}
export function assertThrowsRestError(testFunction, expectedStatusCode, message = "") {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield testFunction();
            assert.fail(`${message}: No error thrown`);
        }
        catch (err) {
            if (err instanceof RestError) {
                assert.equal(expectedStatusCode, err.statusCode, message);
                return err;
            }
            assert.fail(`${message}: Caught error but wasn't a RestError: ${err}`);
        }
        return new Error("We won't reach this - both cases above throw because of assert.fail()");
    });
}
export function assertThrowsAbortError(testFunction, message = "") {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield testFunction();
            assert.fail(`${message}: No error thrown`);
        }
        catch (e) {
            if (isPlaybackMode() && (e.name === "FetchError" || e.name === "AbortError")) {
                return e;
            }
            else {
                assert.equal(e.name, "AbortError");
                return e;
            }
        }
    });
}
//# sourceMappingURL=testHelpers.js.map