import { __awaiter } from "tslib";
import { createAppConfigurationClientForTests, assertThrowsRestError, deleteKeyCompletely, assertThrowsAbortError, startRecorder } from "./testHelpers";
import * as assert from "assert";
describe("AppConfigurationClient (set|clear)ReadOnly", () => {
    let client;
    let recorder;
    const testConfigSetting = {
        key: "",
        value: "world",
        label: "some label"
    };
    beforeEach(function () {
        return __awaiter(this, void 0, void 0, function* () {
            recorder = startRecorder(this);
            testConfigSetting.key = recorder.getUniqueName("readOnlyTests");
            client = createAppConfigurationClientForTests() || this.skip();
            // before it's set to read only we can set it all we want
            yield client.setConfigurationSetting(testConfigSetting);
        });
    });
    afterEach(function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield deleteKeyCompletely([testConfigSetting.key], client);
            recorder.stop();
        });
    });
    it("basic", function () {
        return __awaiter(this, void 0, void 0, function* () {
            let storedSetting = yield client.getConfigurationSetting({
                key: testConfigSetting.key,
                label: testConfigSetting.label
            });
            assert.ok(!storedSetting.isReadOnly);
            yield client.setReadOnly(testConfigSetting, true);
            storedSetting = yield client.getConfigurationSetting({
                key: testConfigSetting.key,
                label: testConfigSetting.label
            });
            assert.ok(storedSetting.isReadOnly);
            // any modification related methods throw exceptions
            yield assertThrowsRestError(() => client.setConfigurationSetting(testConfigSetting), 409, "Set should fail because the setting is read-only");
            yield assertThrowsRestError(() => client.deleteConfigurationSetting({
                key: testConfigSetting.key,
                label: testConfigSetting.label
            }), 409, "Delete should fail because the setting is read-only");
        });
    });
    it("accepts operation options", function () {
        return __awaiter(this, void 0, void 0, function* () {
            yield client.getConfigurationSetting({
                key: testConfigSetting.key,
                label: testConfigSetting.label
            });
            yield assertThrowsAbortError(() => __awaiter(this, void 0, void 0, function* () {
                yield client.setReadOnly(testConfigSetting, true, { requestOptions: { timeout: 1 } });
            }));
            yield assertThrowsAbortError(() => __awaiter(this, void 0, void 0, function* () {
                yield client.setReadOnly(testConfigSetting, false, { requestOptions: { timeout: 1 } });
            }));
        });
    });
});
//# sourceMappingURL=index.readonlytests.spec.js.map