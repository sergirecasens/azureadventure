// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __awaiter } from "tslib";
// https://azure.github.io/azure-sdk/typescript_design.html#ts-config-lib
/// <reference lib="esnext.asynciterable" />
import { AppConfigCredential } from "./appConfigCredential";
import { AppConfiguration } from "./generated/src/appConfiguration";
import { operationOptionsToRequestOptionsBase, isTokenCredential, exponentialRetryPolicy, systemErrorRetryPolicy, getDefaultUserAgentValue as getCoreHttpDefaultUserAgentValue, userAgentPolicy } from "@azure/core-http";
import { throttlingRetryPolicy } from "./policies/throttlingRetryPolicy";
import "@azure/core-asynciterator-polyfill";
import { checkAndFormatIfAndIfNoneMatch, extractAfterTokenFromNextLink, formatWildcards, makeConfigurationSettingEmpty, transformKeyValueResponse, transformKeyValueResponseWithStatusCode, transformKeyValue, formatAcceptDateTime } from "./internal/helpers";
import { tracingPolicy } from "@azure/core-http";
import { Spanner } from "./internal/tracingHelpers";
import { syncTokenPolicy, SyncTokens } from "./internal/synctokenpolicy";
const packageName = "azsdk-js-app-configuration";
/**
 * This constant should always be the same as the package.json's version - we use it when forming the
 * User - Agent header. There's a unit test that makes sure it always stays in sync.
 * @internal
 * @ignore
 */
export const packageVersion = "1.1.0";
const apiVersion = "1.0";
const ConnectionStringRegex = /Endpoint=(.*);Id=(.*);Secret=(.*)/;
const deserializationContentTypes = {
    json: [
        "application/vnd.microsoft.appconfig.kvset+json",
        "application/vnd.microsoft.appconfig.kv+json",
        "application/vnd.microsoft.appconfig.kvs+json",
        "application/vnd.microsoft.appconfig.keyset+json",
        "application/vnd.microsoft.appconfig.revs+json"
    ]
};
/**
 * Client for the Azure App Configuration service.
 */
export class AppConfigurationClient {
    constructor(connectionStringOrEndpoint, tokenCredentialOrOptions, options) {
        let appConfigOptions = {};
        let appConfigCredential;
        let appConfigEndpoint;
        if (isTokenCredential(tokenCredentialOrOptions)) {
            appConfigOptions = options || {};
            appConfigCredential = tokenCredentialOrOptions;
            appConfigEndpoint = connectionStringOrEndpoint;
        }
        else {
            appConfigOptions = tokenCredentialOrOptions || {};
            const regexMatch = connectionStringOrEndpoint.match(ConnectionStringRegex);
            if (regexMatch) {
                appConfigCredential = new AppConfigCredential(regexMatch[2], regexMatch[3]);
                appConfigEndpoint = regexMatch[1];
            }
            else {
                throw new Error(`Invalid connection string. Valid connection strings should match the regex '${ConnectionStringRegex.source}'.`);
            }
        }
        const syncTokens = appConfigOptions.syncTokens || new SyncTokens();
        this.client = new AppConfiguration(appConfigCredential, apiVersion, getGeneratedClientOptions(appConfigEndpoint, syncTokens, appConfigOptions));
        this.spanner = new Spanner("Azure.Data.AppConfiguration");
    }
    /**
     * Add a setting into the Azure App Configuration service, failing if it
     * already exists.
     *
     * Example usage:
     * ```ts
     * const result = await client.addConfigurationSetting({ key: "MyKey", label: "MyLabel", value: "MyValue" });
     * ```
     * @param configurationSetting A configuration setting.
     * @param options Optional parameters for the request.
     */
    addConfigurationSetting(configurationSetting, options = {}) {
        const opts = operationOptionsToRequestOptionsBase(options);
        return this.spanner.trace("addConfigurationSetting", opts, (newOptions) => __awaiter(this, void 0, void 0, function* () {
            const originalResponse = yield this.client.putKeyValue(configurationSetting.key, Object.assign({ ifNoneMatch: "*", label: configurationSetting.label, entity: configurationSetting }, newOptions));
            return transformKeyValueResponse(originalResponse);
        }));
    }
    /**
     * Delete a setting from the Azure App Configuration service
     *
     * Example usage:
     * ```ts
     * const deletedSetting = await client.deleteConfigurationSetting({ key: "MyKey", label: "MyLabel" });
     * ```
     * @param id The id of the configuration setting to delete.
     * @param options Optional parameters for the request (ex: etag, label)
     */
    deleteConfigurationSetting(id, options = {}) {
        const opts = operationOptionsToRequestOptionsBase(options);
        return this.spanner.trace("deleteConfigurationSetting", opts, (newOptions) => __awaiter(this, void 0, void 0, function* () {
            const originalResponse = yield this.client.deleteKeyValue(id.key, Object.assign(Object.assign({ label: id.label }, newOptions), checkAndFormatIfAndIfNoneMatch(id, options)));
            return transformKeyValueResponseWithStatusCode(originalResponse);
        }));
    }
    /**
     * Gets a setting from the Azure App Configuration service.
     *
     * Example code:
     * ```ts
     * const setting = await client.getConfigurationSetting({ key: "MyKey", label: "MyLabel" });
     * ```
     * @param id The id of the configuration setting to get.
     * @param options Optional parameters for the request.
     */
    getConfigurationSetting(id, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = operationOptionsToRequestOptionsBase(options);
            return yield this.spanner.trace("getConfigurationSetting", opts, (newOptions) => __awaiter(this, void 0, void 0, function* () {
                const originalResponse = yield this.client.getKeyValue(id.key, Object.assign(Object.assign(Object.assign({ label: id.label, select: newOptions.fields }, newOptions), formatAcceptDateTime(options)), checkAndFormatIfAndIfNoneMatch(id, options)));
                const response = transformKeyValueResponseWithStatusCode(originalResponse);
                // 304 only comes back if the user has passed a conditional option in their
                // request _and_ the remote object has the same etag as what the user passed.
                if (response.statusCode === 304) {
                    // this is one of our few 'required' fields so we'll make sure it does get initialized
                    // with a value
                    response.key = id.key;
                    // and now we'll undefine all the other properties that are not HTTP related
                    makeConfigurationSettingEmpty(response);
                }
                return response;
            }));
        });
    }
    /**
     * Lists settings from the Azure App Configuration service, optionally
     * filtered by key names, labels and accept datetime.
     *
     * Example code:
     * ```ts
     * const allSettingsWithLabel = client.listConfigurationSettings({ labels: [ "MyLabel" ] });
     * ```
     * @param options Optional parameters for the request.
     */
    listConfigurationSettings(options = {}) {
        const iter = this.getListConfigurationSettingsIterator(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (_ = {}) => {
                // The appconfig service doesn't currently support letting you select a page size
                // so we're ignoring their setting for now.
                return this.listConfigurationSettingsByPage(options);
            }
        };
    }
    getListConfigurationSettingsIterator(options) {
        return __asyncGenerator(this, arguments, function* getListConfigurationSettingsIterator_1() {
            var e_1, _a;
            try {
                for (var _b = __asyncValues(this.listConfigurationSettingsByPage(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const configurationSetting of page.items) {
                        yield yield __await(configurationSetting);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    listConfigurationSettingsByPage(options = {}) {
        return __asyncGenerator(this, arguments, function* listConfigurationSettingsByPage_1() {
            const opts = operationOptionsToRequestOptionsBase(options);
            let currentResponse = yield __await(this.spanner.trace("listConfigurationSettings", opts, (newOptions) => __awaiter(this, void 0, void 0, function* () {
                const response = yield this.client.getKeyValues(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatWildcards(newOptions)));
                return response;
            })));
            yield __await(yield* __asyncDelegator(__asyncValues(this.createListConfigurationPageFromResponse(currentResponse))));
            while (currentResponse.nextLink) {
                currentResponse = yield __await(this.spanner.trace("listConfigurationSettings", opts, 
                // TODO: same code up above. Unify.
                (newOptions) => __awaiter(this, void 0, void 0, function* () {
                    const response = yield this.client.getKeyValues(Object.assign(Object.assign(Object.assign({}, newOptions), formatWildcards(newOptions)), { after: extractAfterTokenFromNextLink(currentResponse.nextLink) }));
                    return response;
                })));
                if (!currentResponse.items) {
                    break;
                }
                yield __await(yield* __asyncDelegator(__asyncValues(this.createListConfigurationPageFromResponse(currentResponse))));
            }
        });
    }
    *createListConfigurationPageFromResponse(currentResponse) {
        yield Object.assign(Object.assign({}, currentResponse), { items: currentResponse.items != null ? currentResponse.items.map(transformKeyValue) : [] });
    }
    /**
     * Lists revisions of a set of keys, optionally filtered by key names,
     * labels and accept datetime.
     *
     * Example code:
     * ```ts
     * const revisionsIterator = client.listRevisions({ keys: ["MyKey"] });
     * ```
     * @param options Optional parameters for the request.
     */
    listRevisions(options) {
        const iter = this.getListRevisionsIterator(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (_ = {}) => {
                // The appconfig service doesn't currently support letting you select a page size
                // so we're ignoring their setting for now.
                return this.listRevisionsByPage(options);
            }
        };
    }
    getListRevisionsIterator(options) {
        return __asyncGenerator(this, arguments, function* getListRevisionsIterator_1() {
            var e_2, _a;
            try {
                for (var _b = __asyncValues(this.listRevisionsByPage(options)), _c; _c = yield __await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    for (const item of page.items) {
                        yield yield __await(item);
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    listRevisionsByPage(options = {}) {
        return __asyncGenerator(this, arguments, function* listRevisionsByPage_1() {
            const opts = operationOptionsToRequestOptionsBase(options);
            let currentResponse = yield __await(this.spanner.trace("listRevisions", opts, (newOptions) => __awaiter(this, void 0, void 0, function* () {
                const response = yield this.client.getRevisions(Object.assign(Object.assign(Object.assign({}, newOptions), formatAcceptDateTime(options)), formatWildcards(newOptions)));
                return response;
            })));
            yield yield __await(Object.assign(Object.assign({}, currentResponse), { items: currentResponse.items != null ? currentResponse.items.map(transformKeyValue) : [] }));
            while (currentResponse.nextLink) {
                currentResponse = yield __await(this.spanner.trace("listRevisions", opts, (newOptions) => {
                    return this.client.getRevisions(Object.assign(Object.assign(Object.assign({}, newOptions), formatWildcards(newOptions)), { select: newOptions.fields, after: extractAfterTokenFromNextLink(currentResponse.nextLink) }));
                }));
                if (!currentResponse.items) {
                    break;
                }
                yield yield __await(Object.assign(Object.assign({}, currentResponse), { items: currentResponse.items != null ? currentResponse.items.map(transformKeyValue) : [] }));
            }
        });
    }
    /**
     * Sets the value of a key in the Azure App Configuration service, allowing for an optional etag.
     * @param key The name of the key.
     * @param configurationSetting A configuration value.
     * @param options Optional parameters for the request.
     *
     * Example code:
     * ```ts
     * await client.setConfigurationSetting({ key: "MyKey", value: "MyValue" });
     * ```
     */
    setConfigurationSetting(configurationSetting, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = operationOptionsToRequestOptionsBase(options);
            return yield this.spanner.trace("setConfigurationSetting", opts, (newOptions) => __awaiter(this, void 0, void 0, function* () {
                const response = yield this.client.putKeyValue(configurationSetting.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: configurationSetting.label, entity: configurationSetting }), checkAndFormatIfAndIfNoneMatch(configurationSetting, options)));
                return transformKeyValueResponse(response);
            }));
        });
    }
    /**
     * Sets or clears a key's read-only status.
     * @param id The id of the configuration setting to modify.
     */
    setReadOnly(id, readOnly, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const opts = operationOptionsToRequestOptionsBase(options);
            return this.spanner.trace("setReadOnly", opts, (newOptions) => __awaiter(this, void 0, void 0, function* () {
                if (readOnly) {
                    const response = yield this.client.putLock(id.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: id.label }), checkAndFormatIfAndIfNoneMatch(id, options)));
                    return transformKeyValueResponse(response);
                }
                else {
                    const response = yield this.client.deleteLock(id.key, Object.assign(Object.assign(Object.assign({}, newOptions), { label: id.label }), checkAndFormatIfAndIfNoneMatch(id, options)));
                    return transformKeyValueResponse(response);
                }
            }));
        });
    }
}
/**
 * Gets the options for the generated AppConfigurationClient
 * @internal
 * @ignore
 */
export function getGeneratedClientOptions(baseUri, syncTokens, internalAppConfigOptions) {
    const retryPolicies = [
        exponentialRetryPolicy(),
        systemErrorRetryPolicy(),
        throttlingRetryPolicy()
    ];
    const userAgent = getUserAgentPrefix(internalAppConfigOptions.userAgentOptions &&
        internalAppConfigOptions.userAgentOptions.userAgentPrefix);
    return {
        baseUri,
        deserializationContentTypes,
        // we'll add in our own custom retry policies
        noRetryPolicy: true,
        requestPolicyFactories: (defaults) => [
            tracingPolicy({ userAgent }),
            syncTokenPolicy(syncTokens),
            userAgentPolicy({ value: userAgent }),
            ...retryPolicies,
            ...defaults
        ],
        generateClientRequestIdHeader: true
    };
}
/**
 * @internal
 * @ignore
 */
export function getUserAgentPrefix(userSuppliedUserAgent) {
    const appConfigDefaultUserAgent = `${packageName}/${packageVersion} ${getCoreHttpDefaultUserAgentValue()}`;
    if (!userSuppliedUserAgent) {
        return appConfigDefaultUserAgent;
    }
    return `${userSuppliedUserAgent} ${appConfigDefaultUserAgent}`;
}
//# sourceMappingURL=appConfigurationClient.js.map