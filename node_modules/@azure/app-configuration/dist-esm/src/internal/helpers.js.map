{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../src/internal/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { ListConfigurationSettingsOptions } from \"..\";\nimport { URLBuilder } from \"@azure/core-http\";\nimport {\n  ListRevisionsOptions,\n  ConfigurationSettingId,\n  ConfigurationSetting,\n  HttpResponseField,\n  HttpResponseFields,\n  HttpOnlyIfChangedField,\n  HttpOnlyIfUnchangedField\n} from \"../models\";\nimport { AppConfigurationGetKeyValuesOptionalParams, KeyValue } from \"../generated/src/models\";\n\n/**\n * Formats the etag so it can be used with a If-Match/If-None-Match header\n * @internal\n * @ignore\n */\nexport function quoteETag(etag: string | undefined): string | undefined {\n  // https://tools.ietf.org/html/rfc7232#section-3.1\n  if (etag === undefined || etag === \"*\") {\n    return etag;\n  }\n\n  if (etag.startsWith('\"') && etag.endsWith('\"')) {\n    return etag;\n  }\n\n  if (etag.startsWith(\"'\") && etag.endsWith(\"'\")) {\n    return etag;\n  }\n\n  return `\"${etag}\"`;\n}\n\n/**\n * Checks the onlyIfChanged/onlyIfUnchanged properties to make sure we haven't specified both\n * and throws an Error. Otherwise, returns the properties properly quoted.\n * @param options An options object with onlyIfChanged/onlyIfUnchanged fields\n * @internal\n * @ignore\n */\nexport function checkAndFormatIfAndIfNoneMatch(\n  configurationSetting: ConfigurationSettingId,\n  options: HttpOnlyIfChangedField & HttpOnlyIfUnchangedField\n): { ifMatch: string | undefined; ifNoneMatch: string | undefined } {\n  if (options.onlyIfChanged && options.onlyIfUnchanged) {\n    throw new Error(\"onlyIfChanged and onlyIfUnchanged are mutually-exclusive\");\n  }\n\n  let ifMatch;\n  let ifNoneMatch;\n\n  if (options.onlyIfUnchanged) {\n    ifMatch = quoteETag(configurationSetting.etag);\n  }\n\n  if (options.onlyIfChanged) {\n    ifNoneMatch = quoteETag(configurationSetting.etag);\n  }\n\n  return {\n    ifMatch: ifMatch,\n    ifNoneMatch: ifNoneMatch\n  };\n}\n\n/**\n * Transforms the keys/labels parameters in the listConfigurationSettings and listRevisions\n * into the format the REST call will need.\n *\n * @internal\n * @ignore\n */\nexport function formatWildcards(\n  listConfigOptions: ListConfigurationSettingsOptions | ListRevisionsOptions\n): Pick<AppConfigurationGetKeyValuesOptionalParams, \"key\" | \"label\" | \"select\" | \"acceptDatetime\"> {\n  let fieldsToGet: (keyof KeyValue)[] | undefined;\n\n  if (listConfigOptions.fields) {\n    fieldsToGet = listConfigOptions.fields.map((opt) => {\n      if (opt === \"isReadOnly\") {\n        return \"locked\";\n      }\n\n      return opt;\n    });\n  }\n\n  let acceptDatetime: string | undefined = undefined;\n\n  if (listConfigOptions.acceptDateTime) {\n    acceptDatetime = listConfigOptions.acceptDateTime.toISOString();\n  }\n\n  return {\n    key: listConfigOptions.keyFilter,\n    label: listConfigOptions.labelFilter,\n    acceptDatetime,\n    select: fieldsToGet\n  };\n}\n\n/**\n * Handles translating a Date acceptDateTime into a string as needed by the API\n * @param newOptions A newer style options with acceptDateTime as a date (and with proper casing!)\n * @internal\n * @ignore\n */\nexport function formatAcceptDateTime(newOptions: {\n  acceptDateTime?: Date;\n}): { acceptDatetime?: string } {\n  return {\n    acceptDatetime: newOptions.acceptDateTime && newOptions.acceptDateTime.toISOString()\n  };\n}\n\n/**\n * Take the URL that gets returned from next link and extract the 'after' token needed\n * to get the next page of results.\n * @internal\n * @ignore\n */\nexport function extractAfterTokenFromNextLink(nextLink: string) {\n  let parsedLink = URLBuilder.parse(nextLink);\n  let afterToken = parsedLink.getQueryParameterValue(\"after\");\n\n  if (afterToken == null || Array.isArray(afterToken)) {\n    throw new Error(\"Invalid nextLink - invalid after token\");\n  }\n\n  return decodeURIComponent(afterToken);\n}\n\n/**\n * Makes a ConfigurationSetting-based response throw for all of the data members. Used primarily\n * to prevent possible errors by the user in accessing a model that is uninitialized. This can happen\n * in cases like HTTP status code 204 or 304, which return an empty response body.\n *\n * @param configurationSetting The configuration setting to alter\n */\nexport function makeConfigurationSettingEmpty(\n  configurationSetting: Partial<Record<Exclude<keyof ConfigurationSetting, \"key\">, any>>\n) {\n  const names: Exclude<keyof ConfigurationSetting, \"key\">[] = [\n    \"contentType\",\n    \"etag\",\n    \"label\",\n    \"lastModified\",\n    \"isReadOnly\",\n    \"tags\",\n    \"value\"\n  ];\n\n  for (const name of names) {\n    configurationSetting[name] = undefined;\n  }\n}\n\n/**\n * @ignore\n * @internal\n */\nexport function transformKeyValue(kvp: KeyValue): ConfigurationSetting {\n  const obj: ConfigurationSetting & KeyValue = {\n    ...kvp,\n    isReadOnly: !!kvp.locked\n  };\n\n  delete obj.locked;\n  return obj;\n}\n\n/**\n * @ignore\n * @internal\n */\nexport function transformKeyValueResponseWithStatusCode<\n  T extends KeyValue & HttpResponseField<any>\n>(kvp: T): ConfigurationSetting & { eTag?: string } & HttpResponseField<any> & HttpResponseFields {\n  return normalizeResponse(kvp, <\n    ConfigurationSetting & HttpResponseField<any> & HttpResponseFields\n  >{\n    ...transformKeyValue(kvp),\n    statusCode: kvp._response.status\n  });\n}\n\n/**\n * @ignore\n * @internal\n */\nexport function transformKeyValueResponse<\n  T extends KeyValue & { eTag?: string } & HttpResponseField<any>\n>(kvp: T): ConfigurationSetting & HttpResponseField<any> {\n  return normalizeResponse(kvp, <ConfigurationSetting & HttpResponseField<any>>{\n    ...transformKeyValue(kvp)\n  });\n}\n\nfunction normalizeResponse<T extends HttpResponseField<any> & { eTag?: string }>(\n  originalResponse: HttpResponseField<any>,\n  newResponse: T\n): T {\n  Object.defineProperty(newResponse, \"_response\", {\n    enumerable: false,\n    value: originalResponse._response\n  });\n\n  // this field comes from the header but it's redundant with\n  // the one serialized in the model itself\n  delete newResponse.eTag;\n\n  return newResponse;\n}\n"]}