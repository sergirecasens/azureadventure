{"version":3,"file":"managedIdentityCredential.js","sourceRoot":"","sources":["../../../src/credentials/managedIdentityCredential.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport qs from \"qs\";\nimport {\n  AccessToken,\n  GetTokenOptions,\n  RequestPrepareOptions,\n  RestError,\n  TokenCredential\n} from \"@azure/core-http\";\nimport { IdentityClient, TokenCredentialOptions } from \"../client/identityClient\";\nimport { createSpan } from \"../util/tracing\";\nimport {\n  AuthenticationErrorName,\n  AuthenticationError,\n  CredentialUnavailable\n} from \"../client/errors\";\nimport { CanonicalCode } from \"@opentelemetry/api\";\nimport { credentialLogger, formatSuccess, formatError } from \"../util/logging\";\n\nconst DefaultScopeSuffix = \"/.default\";\nexport const ImdsEndpoint = \"http://169.254.169.254/metadata/identity/oauth2/token\";\nexport const ImdsApiVersion = \"2018-02-01\";\nexport const AppServiceMsiApiVersion = \"2017-09-01\";\nconst logger = credentialLogger(\"ManagedIdentityCredential\");\n\n/**\n * Attempts authentication using a managed identity that has been assigned\n * to the deployment environment.  This authentication type works in Azure VMs,\n * App Service and Azure Functions applications, and inside of Azure Cloud Shell.\n *\n * More information about configuring managed identities can be found here:\n *\n * https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview\n */\nexport class ManagedIdentityCredential implements TokenCredential {\n  private identityClient: IdentityClient;\n  private clientId: string | undefined;\n  private isEndpointUnavailable: boolean | null = null;\n\n  /**\n   * Creates an instance of ManagedIdentityCredential with the client ID of a\n   * user-assigned identity.\n   *\n   * @param clientId The client ID of the user-assigned identity.\n   * @param options Options for configuring the client which makes the access token request.\n   */\n  constructor(clientId: string, options?: TokenCredentialOptions);\n  /**\n   * Creates an instance of ManagedIdentityCredential\n   *\n   * @param options Options for configuring the client which makes the access token request.\n   */\n  constructor(options?: TokenCredentialOptions);\n  /**\n   * @internal\n   * @ignore\n   */\n  constructor(\n    clientIdOrOptions: string | TokenCredentialOptions | undefined,\n    options?: TokenCredentialOptions\n  ) {\n    if (typeof clientIdOrOptions === \"string\") {\n      // clientId, options constructor\n      this.clientId = clientIdOrOptions;\n      this.identityClient = new IdentityClient(options);\n    } else {\n      // options only constructor\n      this.identityClient = new IdentityClient(clientIdOrOptions);\n    }\n  }\n\n  private mapScopesToResource(scopes: string | string[]): string {\n    let scope = \"\";\n    if (Array.isArray(scopes)) {\n      if (scopes.length !== 1) {\n        throw new Error(\n          \"To convert to a resource string the specified array must be exactly length 1\"\n        );\n      }\n\n      scope = scopes[0];\n    } else if (typeof scopes === \"string\") {\n      scope = scopes;\n    }\n\n    if (!scope.endsWith(DefaultScopeSuffix)) {\n      return scope;\n    }\n\n    return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));\n  }\n\n  private createImdsAuthRequest(resource: string, clientId?: string): RequestPrepareOptions {\n    const queryParameters: any = {\n      resource,\n      \"api-version\": ImdsApiVersion\n    };\n\n    if (clientId) {\n      queryParameters.client_id = clientId;\n    }\n\n    return {\n      url: ImdsEndpoint,\n      method: \"GET\",\n      queryParameters,\n      headers: {\n        Accept: \"application/json\",\n        Metadata: true\n      }\n    };\n  }\n\n  private createAppServiceMsiAuthRequest(\n    resource: string,\n    clientId?: string\n  ): RequestPrepareOptions {\n    const queryParameters: any = {\n      resource,\n      \"api-version\": AppServiceMsiApiVersion\n    };\n\n    if (clientId) {\n      queryParameters.clientid = clientId;\n    }\n\n    return {\n      url: process.env.MSI_ENDPOINT,\n      method: \"GET\",\n      queryParameters,\n      headers: {\n        Accept: \"application/json\",\n        secret: process.env.MSI_SECRET\n      }\n    };\n  }\n\n  private createCloudShellMsiAuthRequest(\n    resource: string,\n    clientId?: string\n  ): RequestPrepareOptions {\n    const body: any = {\n      resource\n    };\n\n    if (clientId) {\n      body.client_id = clientId;\n    }\n\n    return {\n      url: process.env.MSI_ENDPOINT,\n      method: \"POST\",\n      body: qs.stringify(body),\n      headers: {\n        Accept: \"application/json\",\n        Metadata: true,\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n      }\n    };\n  }\n\n  private async pingImdsEndpoint(\n    resource: string,\n    clientId?: string,\n    getTokenOptions?: GetTokenOptions\n  ): Promise<boolean> {\n    const { span, options } = createSpan(\n      \"ManagedIdentityCredential-pingImdsEndpoint\",\n      getTokenOptions\n    );\n    const request = this.createImdsAuthRequest(resource, clientId);\n\n    // This will always be populated, but let's make TypeScript happy\n    if (request.headers) {\n      // Remove the Metadata header to invoke a request error from\n      // IMDS endpoint\n      delete request.headers.Metadata;\n    }\n\n    request.spanOptions = options.tracingOptions && options.tracingOptions.spanOptions;\n\n    try {\n      // Create a request with a timeout since we expect that\n      // not having a \"Metadata\" header should cause an error to be\n      // returned quickly from the endpoint, proving its availability.\n      const webResource = this.identityClient.createWebResource(request);\n      webResource.timeout = (options.requestOptions && options.requestOptions.timeout) || 500;\n\n      try {\n        logger.info(`Pinging IMDS endpoint`);\n        await this.identityClient.sendRequest(webResource);\n      } catch (err) {\n        if (\n          (err instanceof RestError && err.code === RestError.REQUEST_SEND_ERROR) ||\n          err.name === \"AbortError\"\n        ) {\n          // Either request failed or IMDS endpoint isn't available\n          logger.info(`IMDS endpoint unavailable`);\n          span.setStatus({\n            code: CanonicalCode.UNAVAILABLE,\n            message: err.message\n          });\n          return false;\n        }\n      }\n\n      // If we received any response, the endpoint is available\n      logger.info(`IMDS endpoint is available`);\n      return true;\n    } catch (err) {\n      logger.info(formatError(`Error when accessing IMDS endpoint: ${err.message}`));\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async authenticateManagedIdentity(\n    scopes: string | string[],\n    checkIfImdsEndpointAvailable: boolean,\n    clientId?: string,\n    getTokenOptions?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    let authRequestOptions: RequestPrepareOptions;\n    const resource = this.mapScopesToResource(scopes);\n    let expiresInParser: ((requestBody: any) => number) | undefined;\n\n    const { span, options } = createSpan(\n      \"ManagedIdentityCredential-authenticateManagedIdentity\",\n      getTokenOptions\n    );\n\n    try {\n      // Detect which type of environment we are running in\n      if (process.env.MSI_ENDPOINT) {\n        if (process.env.MSI_SECRET) {\n          // Running in App Service\n          authRequestOptions = this.createAppServiceMsiAuthRequest(resource, clientId);\n          expiresInParser = (requestBody: any) => {\n            // Parse a date format like \"06/20/2019 02:57:58 +00:00\" and\n            // convert it into a JavaScript-formatted date\n            return Date.parse(requestBody.expires_on);\n          };\n          logger.info(\n            `Using the endpoint and the secret coming form the environment variables: MSI_ENDPOINT=${process.env.MSI_ENDPOINT} and MSI_SECRET=[REDACTED].`\n          );\n        } else {\n          logger.info(\n            `Using the endpoint coming form the environment variable MSI_ENDPOINT=${process.env.MSI_ENDPOINT}, and using the cloud shell to proceed with the authentication.`\n          );\n          // Running in Cloud Shell\n          authRequestOptions = this.createCloudShellMsiAuthRequest(resource, clientId);\n        }\n      } else {\n        expiresInParser = (requestBody: any) => {\n          if (requestBody.expires_on) {\n            // Use the expires_on timestamp if it's available\n            const expires = +requestBody.expires_on * 1000;\n            logger.info(\n              `IMDS using expires_on: ${expires} (original value: ${requestBody.expires_on})`\n            );\n            return expires;\n          } else {\n            // If these aren't possible, use expires_in and calculate a timestamp\n            const expires = Date.now() + requestBody.expires_in * 1000;\n            logger.info(\n              `IMDS using expires_in: ${expires} (original value: ${requestBody.expires_in})`\n            );\n            return expires;\n          }\n        };\n        logger.info(\n          `Using the IMDS endpoint coming form the environment variable MSI_ENDPOINT=${process.env.MSI_ENDPOINT}, and using the cloud shell to proceed with the authentication.`\n        );\n        // Ping the IMDS endpoint to see if it's available\n        if (\n          !checkIfImdsEndpointAvailable ||\n          (await this.pingImdsEndpoint(resource, clientId, options))\n        ) {\n          // Running in an Azure VM\n          authRequestOptions = this.createImdsAuthRequest(resource, clientId);\n        } else {\n          // Returning null tells the ManagedIdentityCredential that\n          // no MSI authentication endpoints are available\n          return null;\n        }\n      }\n\n      const webResource = this.identityClient.createWebResource({\n        disableJsonStringifyOnBody: true,\n        deserializationMapper: undefined,\n        abortSignal: options.abortSignal,\n        spanOptions: options.tracingOptions && options.tracingOptions.spanOptions,\n        ...authRequestOptions\n      });\n\n      const tokenResponse = await this.identityClient.sendTokenRequest(\n        webResource,\n        expiresInParser\n      );\n      return (tokenResponse && tokenResponse.accessToken) || null;\n    } catch (err) {\n      const code =\n        err.name === AuthenticationErrorName\n          ? CanonicalCode.UNAUTHENTICATED\n          : CanonicalCode.UNKNOWN;\n      span.setStatus({\n        code,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Authenticates with Azure Active Directory and returns an access token if\n   * successful.  If authentication cannot be performed at this time, this method may\n   * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n   * containing failure details will be thrown.\n   *\n   * @param scopes The list of scopes for which the token will have access.\n   * @param options The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  public async getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    let result: AccessToken | null = null;\n\n    const { span, options: newOptions } = createSpan(\"ManagedIdentityCredential-getToken\", options);\n\n    try {\n      // isEndpointAvailable can be true, false, or null,\n      // the latter indicating that we don't yet know whether\n      // the endpoint is available and need to check for it.\n      if (this.isEndpointUnavailable !== true) {\n        result = await this.authenticateManagedIdentity(\n          scopes,\n          this.isEndpointUnavailable === null,\n          this.clientId,\n          newOptions\n        );\n\n        // If authenticateManagedIdentity returns null, it means no MSI\n        // endpoints are available.  In this case, don't try them in future\n        // requests.\n        this.isEndpointUnavailable = result === null;\n      } else {\n        const error = new CredentialUnavailable(\n          \"The managed identity endpoint is not currently available\"\n        );\n        logger.getToken.info(formatError(error));\n        throw error;\n      }\n      logger.getToken.info(formatSuccess(scopes));\n      return result;\n    } catch (err) {\n      span.setStatus({\n        code: CanonicalCode.UNKNOWN,\n        message: err.message\n      });\n\n      if (err.code === \"ENETUNREACH\") {\n        const error = new CredentialUnavailable(\n          \"ManagedIdentityCredential is unavailable. No managed identity endpoint found.\"\n        );\n\n        logger.getToken.info(formatError(error));\n        throw error;\n      }\n      throw new AuthenticationError(400, {\n        error: \"ManagedIdentityCredential authentication failed.\",\n        error_description: err.message\n      });\n    } finally {\n      if (this.isEndpointUnavailable) {\n        const error = new CredentialUnavailable(\n          \"ManagedIdentityCredential is unavailable. No managed identity endpoint found.\"\n        );\n        logger.getToken.info(formatError(error));\n        // eslint-disable-next-line no-unsafe-finally\n        throw error;\n      }\n      span.end();\n    }\n  }\n}\n"]}