{"version":3,"file":"deviceCodeCredential.js","sourceRoot":"","sources":["../../../src/credentials/deviceCodeCredential.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport qs from \"qs\";\nimport { TokenCredential, GetTokenOptions, AccessToken } from \"@azure/core-http\";\nimport { IdentityClient, TokenResponse, TokenCredentialOptions } from \"../client/identityClient\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../client/errors\";\nimport { createSpan } from \"../util/tracing\";\nimport { delay } from \"../util/delay\";\nimport { CanonicalCode } from \"@opentelemetry/api\";\nimport { credentialLogger, formatSuccess } from \"../util/logging\";\n\n/**\n * An internal interface that contains the verbatim devicecode response.\n * This interface does not get exported from the public interface of the\n * library.\n */\nexport interface DeviceCodeResponse {\n  device_code: string;\n  user_code: string;\n  verification_uri: string;\n  expires_in: number;\n  interval: number;\n  message: string;\n}\n\n/**\n * Provides the user code and verification URI where the code must be\n * entered.  Also provides a message to display to the user which\n * contains an instruction with these details.\n */\nexport interface DeviceCodeInfo {\n  /**\n   * The device code that the user must enter into the verification page.\n   */\n  userCode: string;\n\n  /**\n   * The verification URI to which the user must navigate to enter the device\n   * code.\n   */\n  verificationUri: string;\n\n  /**\n   * A message that may be shown to the user to instruct them on how to enter\n   * the device code in the page specified by the verification URI.\n   */\n  message: string;\n}\n\n/**\n * Defines the signature of a callback which will be passed to\n * DeviceCodeCredential for the purpose of displaying authentication\n * details to the user.\n */\nexport type DeviceCodePromptCallback = (deviceCodeInfo: DeviceCodeInfo) => void;\n\nconst logger = credentialLogger(\"DeviceCodeCredential\");\n\n/**\n * Enables authentication to Azure Active Directory using a device code\n * that the user can enter into https://microsoft.com/devicelogin.\n */\nexport class DeviceCodeCredential implements TokenCredential {\n  private identityClient: IdentityClient;\n  private tenantId: string;\n  private clientId: string;\n  private userPromptCallback: DeviceCodePromptCallback;\n  private lastTokenResponse: TokenResponse | null = null;\n\n  /**\n   * Creates an instance of DeviceCodeCredential with the details needed\n   * to initiate the device code authorization flow with Azure Active Directory.\n   *\n   * @param tenantId The Azure Active Directory tenant (directory) ID or name. \n   *                 'organizations' may be used when dealing with multi-tenant scenarios.\n   * @param clientId The client (application) ID of an App Registration in the tenant.\n   * @param userPromptCallback A callback function that will be invoked to show\n                               {@link DeviceCodeInfo} to the user.\n   * @param options Options for configuring the client which makes the authentication request.\n   */\n  constructor(\n    tenantId: string | \"organizations\",\n    clientId: string,\n    userPromptCallback: DeviceCodePromptCallback,\n    options?: TokenCredentialOptions\n  ) {\n    this.identityClient = new IdentityClient(options);\n    this.tenantId = tenantId;\n    this.clientId = clientId;\n    this.userPromptCallback = userPromptCallback;\n  }\n\n  private async sendDeviceCodeRequest(\n    scope: string,\n    options?: GetTokenOptions\n  ): Promise<DeviceCodeResponse> {\n    const { span, options: newOptions } = createSpan(\n      \"DeviceCodeCredential-sendDeviceCodeRequest\",\n      options\n    );\n    try {\n      const webResource = this.identityClient.createWebResource({\n        url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/devicecode`,\n        method: \"POST\",\n        disableJsonStringifyOnBody: true,\n        deserializationMapper: undefined,\n        body: qs.stringify({\n          client_id: this.clientId,\n          scope\n        }),\n        headers: {\n          Accept: \"application/json\",\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        },\n        abortSignal: options && options.abortSignal,\n        spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions\n      });\n\n      logger.info(\"Sending devicecode request\");\n\n      const response = await this.identityClient.sendRequest(webResource);\n      if (!(response.status === 200 || response.status === 201)) {\n        throw new AuthenticationError(response.status, response.bodyAsText);\n      }\n\n      return response.parsedBody as DeviceCodeResponse;\n    } catch (err) {\n      const code =\n        err.name === AuthenticationErrorName\n          ? CanonicalCode.UNAUTHENTICATED\n          : CanonicalCode.UNKNOWN;\n\n      if (err.name === AuthenticationErrorName) {\n        logger.info(\n          `Failed to authenticate ${(err as AuthenticationError).errorResponse.errorDescription}`\n        );\n      } else {\n        logger.info(`Failed to authenticate ${err}`);\n      }\n\n      span.setStatus({\n        code,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n\n  private async pollForToken(\n    deviceCodeResponse: DeviceCodeResponse,\n    options?: GetTokenOptions\n  ): Promise<TokenResponse | null> {\n    let tokenResponse: TokenResponse | null = null;\n    const { span, options: newOptions } = createSpan(\"DeviceCodeCredential-pollForToken\", options);\n\n    try {\n      const webResource = this.identityClient.createWebResource({\n        url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,\n        method: \"POST\",\n        disableJsonStringifyOnBody: true,\n        deserializationMapper: undefined,\n        body: qs.stringify({\n          grant_type: \"urn:ietf:params:oauth:grant-type:device_code\",\n          client_id: this.clientId,\n          device_code: deviceCodeResponse.device_code\n        }),\n        headers: {\n          Accept: \"application/json\",\n          \"Content-Type\": \"application/x-www-form-urlencoded\"\n        },\n        abortSignal: options && options.abortSignal,\n        spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions\n      });\n\n      while (tokenResponse === null) {\n        try {\n          await delay(deviceCodeResponse.interval * 1000);\n\n          // Check the abort signal before sending the request\n          if (options && options.abortSignal && options.abortSignal.aborted) {\n            return null;\n          }\n\n          tokenResponse = await this.identityClient.sendTokenRequest(webResource);\n        } catch (err) {\n          if (err.name === AuthenticationErrorName) {\n            switch (err.errorResponse.error) {\n              case \"authorization_pending\":\n                break;\n              case \"authorization_declined\":\n                return null;\n              case \"expired_token\":\n                throw err;\n              case \"bad_verification_code\":\n                throw err;\n              default:\n                // Any other error should be rethrown\n                throw err;\n            }\n          } else {\n            throw err;\n          }\n        }\n      }\n\n      return tokenResponse;\n    } catch (err) {\n      const code =\n        err.name === AuthenticationErrorName\n          ? CanonicalCode.UNAUTHENTICATED\n          : CanonicalCode.UNKNOWN;\n      span.setStatus({\n        code,\n        message: err.message\n      });\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n\n  /**\n   * Authenticates with Azure Active Directory and returns an access token if\n   * successful.  If authentication cannot be performed at this time, this method may\n   * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n   * containing failure details will be thrown.\n   *\n   * @param scopes The list of scopes for which the token will have access.\n   * @param options The options used to configure any requests this\n   *                TokenCredential implementation might make.\n   */\n  public async getToken(\n    scopes: string | string[],\n    options?: GetTokenOptions\n  ): Promise<AccessToken | null> {\n    const { span, options: newOptions } = createSpan(\"DeviceCodeCredential-getToken\", options);\n    try {\n      let tokenResponse: TokenResponse | null = null;\n      let scopeString = typeof scopes === \"string\" ? scopes : scopes.join(\" \");\n      if (scopeString.indexOf(\"offline_access\") < 0) {\n        scopeString += \" offline_access\";\n      }\n\n      // Try to use the refresh token first\n      if (this.lastTokenResponse && this.lastTokenResponse.refreshToken) {\n        tokenResponse = await this.identityClient.refreshAccessToken(\n          this.tenantId,\n          this.clientId,\n          scopeString,\n          this.lastTokenResponse.refreshToken,\n          undefined, // clientSecret not needed for device code auth\n          undefined,\n          newOptions\n        );\n      }\n\n      if (tokenResponse === null) {\n        const deviceCodeResponse = await this.sendDeviceCodeRequest(scopeString, newOptions);\n\n        this.userPromptCallback({\n          userCode: deviceCodeResponse.user_code,\n          verificationUri: deviceCodeResponse.verification_uri,\n          message: deviceCodeResponse.message\n        });\n\n        tokenResponse = await this.pollForToken(deviceCodeResponse, newOptions);\n      }\n\n      this.lastTokenResponse = tokenResponse;\n      logger.getToken.info(formatSuccess(scopes));\n      return (tokenResponse && tokenResponse.accessToken) || null;\n    } catch (err) {\n      const code =\n        err.name === AuthenticationErrorName\n          ? CanonicalCode.UNAUTHENTICATED\n          : CanonicalCode.UNKNOWN;\n      span.setStatus({\n        code,\n        message: err.message\n      });\n      logger.getToken.info(err);\n      throw err;\n    } finally {\n      span.end();\n    }\n  }\n}\n"]}