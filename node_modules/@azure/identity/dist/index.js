'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var coreTracing = require('@azure/core-tracing');
var api = require('@opentelemetry/api');
var logger$c = require('@azure/logger');
var qs = _interopDefault(require('qs'));
var coreHttp = require('@azure/core-http');
var jws = _interopDefault(require('jws'));
var uuid = require('uuid');
var fs = require('fs');
var fs__default = _interopDefault(fs);
var crypto = require('crypto');
var child_process = require('child_process');
var os = _interopDefault(require('os'));
var path = _interopDefault(require('path'));

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isErrorResponse(errorResponse) {
    return (errorResponse &&
        typeof errorResponse.error === "string" &&
        typeof errorResponse.error_description === "string");
}
/**
 * This signifies that the credential that was tried in a chained credential
 * was not available to be used as the credential. Rather than treating this as
 * an error that should halt the chain, it's caught and the chain continues
 */
class CredentialUnavailable extends Error {
}
/**
 * The Error.name value of an AuthenticationError
 */
const AuthenticationErrorName = "AuthenticationError";
/**
 * Provides details about a failure to authenticate with Azure Active
 * Directory.  The `errorResponse` field contains more details about
 * the specific failure.
 */
class AuthenticationError extends Error {
    constructor(statusCode, errorBody) {
        let errorResponse = {
            error: "unknown",
            errorDescription: "An unknown error occurred and no additional details are available."
        };
        if (isErrorResponse(errorBody)) {
            errorResponse = convertOAuthErrorResponseToErrorResponse(errorBody);
        }
        else if (typeof errorBody === "string") {
            try {
                // Most error responses will contain JSON-formatted error details
                // in the response body
                const oauthErrorResponse = JSON.parse(errorBody);
                errorResponse = convertOAuthErrorResponseToErrorResponse(oauthErrorResponse);
            }
            catch (e) {
                if (statusCode === 400) {
                    errorResponse = {
                        error: "authority_not_found",
                        errorDescription: "The specified authority URL was not found."
                    };
                }
                else {
                    errorResponse = {
                        error: "unknown_error",
                        errorDescription: `An unknown error has occurred. Response body:\n\n${errorBody}`
                    };
                }
            }
        }
        else {
            errorResponse = {
                error: "unknown_error",
                errorDescription: "An unknown error occurred and no additional details are available."
            };
        }
        super(`${errorResponse.error}(status code ${statusCode}).\nMore details:\n${errorResponse.errorDescription}`);
        this.statusCode = statusCode;
        this.errorResponse = errorResponse;
        // Ensure that this type reports the correct name
        this.name = AuthenticationErrorName;
    }
}
/**
 * The Error.name value of an AggregateAuthenticationError
 */
const AggregateAuthenticationErrorName = "AggregateAuthenticationError";
/**
 * Provides an `errors` array containing {@link AuthenticationError} instance
 * for authentication failures from credentials in a {@link ChainedTokenCredential}.
 */
class AggregateAuthenticationError extends Error {
    constructor(errors, errorMessage) {
        const errorDetail = errors.join("\n");
        super(`${errorMessage}\n\n${errorDetail}`);
        this.errors = errors;
        // Ensure that this type reports the correct name
        this.name = AggregateAuthenticationErrorName;
    }
}
function convertOAuthErrorResponseToErrorResponse(errorBody) {
    return {
        error: errorBody.error,
        errorDescription: errorBody.error_description,
        correlationId: errorBody.correlation_id,
        errorCodes: errorBody.error_codes,
        timestamp: errorBody.timestamp,
        traceId: errorBody.trace_id
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * Creates a span using the global tracer.
 * @param name The name of the operation being performed.
 * @param options The options for the underlying http request.
 */
function createSpan(operationName, options = {}) {
    const tracer = coreTracing.getTracer();
    const tracingOptions = Object.assign({ spanOptions: {} }, options.tracingOptions);
    const spanOptions = Object.assign(Object.assign({}, tracingOptions.spanOptions), { kind: api.SpanKind.INTERNAL });
    const span = tracer.startSpan(`Azure.Identity.${operationName}`, spanOptions);
    span.setAttribute("az.namespace", "Microsoft.AAD");
    let newOptions = options;
    if (span.isRecording()) {
        newOptions = Object.assign(Object.assign({}, options), { tracingOptions: Object.assign(Object.assign({}, tracingOptions), { spanOptions: Object.assign(Object.assign({}, tracingOptions.spanOptions), { parent: span.context(), attributes: Object.assign(Object.assign({}, spanOptions.attributes), { "az.namespace": "Microsoft.AAD" }) }) }) });
    }
    return {
        span,
        options: newOptions
    };
}

// Copyright (c) Microsoft Corporation.
/**
 * The AzureLogger used for all clients within the identity package
 */
const logger = logger$c.createClientLogger("identity");
/**
 * Separates a list of environment variable names into a plain object with two arrays: an array of missing environment variables and another array with assigned environment variables.
 * @param supportedEnvVars List of environment variable names
 */
function processEnvVars(supportedEnvVars) {
    return supportedEnvVars.reduce((acc, envVariable) => {
        if (process.env[envVariable]) {
            acc.assigned.push(envVariable);
        }
        else {
            acc.missing.push(envVariable);
        }
        return acc;
    }, { missing: [], assigned: [] });
}
/**
 * Formatting the success event on the credentials
 */
function formatSuccess(scope) {
    return `SUCCESS: ${Array.isArray(scope) ? scope.join(", ") : scope}`;
}
/**
 * Formatting the success event on the credentials
 */
function formatError(error) {
    return `ERROR: ${typeof error === "string" ? error : error.message}`;
}
/**
 * Generates a CredentialLoggerInstance.
 *
 * It logs with the format:
 *
 *   [title] => [message]
 *
 */
function credentialLoggerInstance(title, parent, log = logger) {
    const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;
    function info(message) {
        log.info(`${fullTitle} =>`, message);
    }
    return {
        title,
        fullTitle,
        info
    };
}
/**
 * Generates a CredentialLogger, which is a logger declared at the credential's constructor, and used at any point in the credential.
 * It has all the properties of a CredentialLoggerInstance, plus other logger instances, one per method.
 *
 * It logs with the format:
 *
 *   [title] => [message]
 *   [title] => getToken() => [message]
 *
 */
function credentialLogger(title, log = logger) {
    const logger = credentialLoggerInstance(title, undefined, log);
    return Object.assign(Object.assign({}, logger), { getToken: credentialLoggerInstance("=> getToken()", logger, log) });
}

// Copyright (c) Microsoft Corporation.
const logger$1 = credentialLogger("ChainedTokenCredential");
/**
 * Enables multiple `TokenCredential` implementations to be tried in order
 * until one of the getToken methods returns an access token.
 */
class ChainedTokenCredential {
    /**
     * Creates an instance of ChainedTokenCredential using the given credentials.
     *
     * @param sources `TokenCredential` implementations to be tried in order.
     *
     * Example usage:
     * ```javascript
     * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);
     * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);
     * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);
     * ```
     */
    constructor(...sources) {
        /**
         * The message to use when the chained token fails to get a token
         */
        this.UnavailableMessage = "ChainedTokenCredential => failed to retrieve a token from the included credentials";
        this._sources = [];
        this._sources = sources;
    }
    /**
     * Returns the first access token returned by one of the chained
     * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}
     * when one or more credentials throws an {@link AuthenticationError} and
     * no credentials have returned an access token.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                `TokenCredential` implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let token = null;
            const errors = [];
            const { span, options: newOptions } = createSpan("ChainedTokenCredential-getToken", options);
            for (let i = 0; i < this._sources.length && token === null; i++) {
                try {
                    token = yield this._sources[i].getToken(scopes, newOptions);
                }
                catch (err) {
                    if (err instanceof CredentialUnavailable) {
                        errors.push(err);
                    }
                    else {
                        logger$1.getToken.info(formatError(err));
                        throw err;
                    }
                }
            }
            if (!token && errors.length > 0) {
                const err = new AggregateAuthenticationError(errors);
                span.setStatus({
                    code: api.CanonicalCode.UNAUTHENTICATED,
                    message: err.message
                });
                logger$1.getToken.info(formatError(err));
                throw err;
            }
            span.end();
            logger$1.getToken.info(formatSuccess(scopes));
            return token;
        });
    }
}

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function getAuthorityHostEnvironment() {
    if (process.env.AZURE_AUTHORITY_HOST) {
        return {
            authorityHost: process.env.AZURE_AUTHORITY_HOST
        };
    }
    else {
        return undefined;
    }
}

// Copyright (c) Microsoft Corporation.
const DefaultAuthorityHost = "https://login.microsoftonline.com";
class IdentityClient extends coreHttp.ServiceClient {
    constructor(options) {
        {
            options = options || getAuthorityHostEnvironment();
        }
        options = options || IdentityClient.getDefaultOptions();
        super(undefined, coreHttp.createPipelineFromOptions(Object.assign(Object.assign({}, options), { deserializationOptions: {
                expectedContentTypes: {
                    json: ["application/json", "text/json", "text/plain"]
                }
            } })));
        this.baseUri = this.authorityHost = options.authorityHost || DefaultAuthorityHost;
        if (!this.baseUri.startsWith("https:")) {
            throw new Error("The authorityHost address must use the 'https' protocol.");
        }
    }
    createWebResource(requestOptions) {
        const webResource = new coreHttp.WebResource();
        webResource.prepare(requestOptions);
        return webResource;
    }
    sendTokenRequest(webResource, expiresOnParser) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            logger.info(`IdentityClient: sending token request to [${webResource.url}]`);
            const response = yield this.sendRequest(webResource);
            expiresOnParser =
                expiresOnParser ||
                    ((responseBody) => {
                        return Date.now() + responseBody.expires_in * 1000;
                    });
            if (response.status === 200 || response.status === 201) {
                const token = {
                    accessToken: {
                        token: response.parsedBody.access_token,
                        expiresOnTimestamp: expiresOnParser(response.parsedBody)
                    },
                    refreshToken: response.parsedBody.refresh_token
                };
                logger.info(`IdentityClient: [${webResource.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);
                return token;
            }
            else {
                const error = new AuthenticationError(response.status, response.parsedBody || response.bodyAsText);
                logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);
                throw error;
            }
        });
    }
    refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            if (refreshToken === undefined) {
                return null;
            }
            logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);
            const { span, options: newOptions } = createSpan("IdentityClient-refreshAccessToken", options);
            const refreshParams = {
                grant_type: "refresh_token",
                client_id: clientId,
                refresh_token: refreshToken,
                scope: scopes
            };
            if (clientSecret !== undefined) {
                refreshParams.client_secret = clientSecret;
            }
            try {
                const webResource = this.createWebResource({
                    url: `${this.authorityHost}/${tenantId}/oauth2/v2.0/token`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify(refreshParams),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions,
                    abortSignal: options && options.abortSignal
                });
                const response = yield this.sendTokenRequest(webResource, expiresOnParser);
                logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);
                return response;
            }
            catch (err) {
                if (err.name === AuthenticationErrorName &&
                    err.errorResponse.error === "interaction_required") {
                    // It's likely that the refresh token has expired, so
                    // return null so that the credential implementation will
                    // initiate the authentication flow again.
                    logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);
                    span.setStatus({
                        code: api.CanonicalCode.UNAUTHENTICATED,
                        message: err.message
                    });
                    return null;
                }
                else {
                    logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);
                    span.setStatus({
                        code: api.CanonicalCode.UNKNOWN,
                        message: err.message
                    });
                    throw err;
                }
            }
            finally {
                span.end();
            }
        });
    }
    static getDefaultOptions() {
        return {
            authorityHost: DefaultAuthorityHost
        };
    }
}

// Copyright (c) Microsoft Corporation.
const logger$2 = credentialLogger("ClientSecretCredential");
/**
 * Enables authentication to Azure Active Directory using a client secret
 * that was generated for an App Registration.  More information on how
 * to configure a client secret can be found here:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-credentials-to-your-web-application
 *
 */
class ClientSecretCredential {
    /**
     * Creates an instance of the ClientSecretCredential with the details
     * needed to authenticate against Azure Active Directory with a client
     * secret.
     *
     * @param tenantId The Azure Active Directory tenant (directory) ID.
     * @param clientId The client (application) ID of an App Registration in the tenant.
     * @param clientSecret A client secret that was generated for the App Registration.
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, clientSecret, options) {
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantId;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("ClientSecretCredential-getToken", options);
            try {
                const webResource = this.identityClient.createWebResource({
                    url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        response_type: "token",
                        grant_type: "client_credentials",
                        client_id: this.clientId,
                        client_secret: this.clientSecret,
                        scope: typeof scopes === "string" ? scopes : scopes.join(" ")
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                });
                const tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                logger$2.getToken.info(formatSuccess(scopes));
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? api.CanonicalCode.UNAUTHENTICATED
                    : api.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                logger$2.getToken.info(err);
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
const SelfSignedJwtLifetimeMins = 10;
function timestampInSeconds(date) {
    return Math.floor(date.getTime() / 1000);
}
function addMinutes(date, minutes) {
    date.setMinutes(date.getMinutes() + minutes);
    return date;
}
const logger$3 = credentialLogger("ClientCertificateCredential");
/**
 * Enables authentication to Azure Active Directory using a PEM-encoded
 * certificate that is assigned to an App Registration.  More information
 * on how to configure certificate authentication can be found here:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/develop/active-directory-certificate-credentials#register-your-certificate-with-azure-ad
 *
 */
class ClientCertificateCredential {
    /**
     * Creates an instance of the ClientCertificateCredential with the details
     * needed to authenticate against Azure Active Directory with a certificate.
     *
     * @param tenantId The Azure Active Directory tenant (directory) ID.
     * @param clientId The client (application) ID of an App Registration in the tenant.
     * @param certificatePath The path to a PEM-encoded public/private key certificate on the filesystem.
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, certificatePath, options) {
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantId;
        this.clientId = clientId;
        this.certificateString = fs.readFileSync(certificatePath, "utf8");
        const certificatePattern = /(-+BEGIN CERTIFICATE-+)(\n\r?|\r\n?)([A-Za-z0-9+/\n\r]+=*)(\n\r?|\r\n?)(-+END CERTIFICATE-+)/;
        const matchCert = this.certificateString.match(certificatePattern);
        const publicKey = matchCert ? matchCert[3] : "";
        if (!publicKey) {
            const error = new Error("The file at the specified path does not contain a PEM-encoded certificate.");
            logger$3.info(formatError(error));
            throw error;
        }
        this.certificateThumbprint = crypto.createHash("sha1")
            .update(Buffer.from(publicKey, "base64"))
            .digest("hex")
            .toUpperCase();
        this.certificateX5t = Buffer.from(this.certificateThumbprint, "hex").toString("base64");
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("ClientCertificateCredential-getToken", options);
            try {
                const tokenId = uuid.v4();
                const audienceUrl = `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`;
                const header = {
                    typ: "JWT",
                    alg: "RS256",
                    x5t: this.certificateX5t
                };
                const payload = {
                    iss: this.clientId,
                    sub: this.clientId,
                    aud: audienceUrl,
                    jti: tokenId,
                    nbf: timestampInSeconds(new Date()),
                    exp: timestampInSeconds(addMinutes(new Date(), SelfSignedJwtLifetimeMins))
                };
                const clientAssertion = jws.sign({
                    header,
                    payload,
                    secret: this.certificateString
                });
                const webResource = this.identityClient.createWebResource({
                    url: audienceUrl,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        response_type: "token",
                        grant_type: "client_credentials",
                        client_id: this.clientId,
                        client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer",
                        client_assertion: clientAssertion,
                        scope: typeof scopes === "string" ? scopes : scopes.join(" ")
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                });
                const tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                logger$3.getToken.info(formatSuccess(scopes));
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? api.CanonicalCode.UNAUTHENTICATED
                    : api.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                logger$3.getToken.info(formatError(err));
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
const logger$4 = credentialLogger("UsernamePasswordCredential");
/**
 * Enables authentication to Azure Active Directory with a user's
 * username and password. This credential requires a high degree of
 * trust so you should only use it when other, more secure credential
 * types can't be used.
 */
class UsernamePasswordCredential {
    /**
     * Creates an instance of the UsernamePasswordCredential with the details
     * needed to authenticate against Azure Active Directory with a username
     * and password.
     *
     * @param tenantIdOrName The Azure Active Directory tenant (directory) ID or name.
     * @param clientId The client (application) ID of an App Registration in the tenant.
     * @param username The user account's e-mail address (user name).
     * @param password The user account's account password
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tenantIdOrName, clientId, username, password, options) {
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantIdOrName;
        this.clientId = clientId;
        this.username = username;
        this.password = password;
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("UsernamePasswordCredential-getToken", options);
            try {
                const webResource = this.identityClient.createWebResource({
                    url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        response_type: "token",
                        grant_type: "password",
                        client_id: this.clientId,
                        username: this.username,
                        password: this.password,
                        scope: typeof scopes === "string" ? scopes : scopes.join(" ")
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                });
                const tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                logger$4.getToken.info(formatSuccess(scopes));
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? api.CanonicalCode.UNAUTHENTICATED
                    : api.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                logger$4.getToken.info(formatError(err));
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Contains the list of all supported environment variable names so that an
 * appropriate error message can be generated when no credentials can be
 * configured.
 *
 * @internal
 */
const AllSupportedEnvironmentVariables = [
    "AZURE_TENANT_ID",
    "AZURE_CLIENT_ID",
    "AZURE_CLIENT_SECRET",
    "AZURE_CLIENT_CERTIFICATE_PATH",
    "AZURE_USERNAME",
    "AZURE_PASSWORD"
];
const logger$5 = credentialLogger("EnvironmentCredential");
/**
 * Enables authentication to Azure Active Directory using client secret
 * details configured in the following environment variables:
 *
 * - AZURE_TENANT_ID: The Azure Active Directory tenant (directory) ID.
 * - AZURE_CLIENT_ID: The client (application) ID of an App Registration in the tenant.
 * - AZURE_CLIENT_SECRET: A client secret that was generated for the App Registration.
 *
 * This credential ultimately uses a {@link ClientSecretCredential} to
 * perform the authentication using these details.  Please consult the
 * documentation of that class for more details.
 */
class EnvironmentCredential {
    /**
     * Creates an instance of the EnvironmentCredential class and reads
     * client secret details from environment variables.  If the expected
     * environment variables are not found at this time, the getToken method
     * will return null when invoked.
     *
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(options) {
        // Keep track of any missing environment variables for error details
        this._credential = undefined;
        const assigned = processEnvVars(AllSupportedEnvironmentVariables).assigned.join(", ");
        logger$5.info(`Found the following environment variables: ${assigned}`);
        const tenantId = process.env.AZURE_TENANT_ID, clientId = process.env.AZURE_CLIENT_ID, clientSecret = process.env.AZURE_CLIENT_SECRET;
        if (tenantId && clientId && clientSecret) {
            logger$5.info(`Invoking ClientSecretCredential with tenant ID: ${tenantId}, clientId: ${clientId} and clientSecret: [REDACTED]`);
            this._credential = new ClientSecretCredential(tenantId, clientId, clientSecret, options);
            return;
        }
        const certificatePath = process.env.AZURE_CLIENT_CERTIFICATE_PATH;
        if (tenantId && clientId && certificatePath) {
            logger$5.info(`Invoking ClientCertificateCredential with tenant ID: ${tenantId}, clientId: ${clientId} and certificatePath: ${certificatePath}`);
            this._credential = new ClientCertificateCredential(tenantId, clientId, certificatePath, options);
            return;
        }
        const username = process.env.AZURE_USERNAME;
        const password = process.env.AZURE_PASSWORD;
        if (tenantId && clientId && username && password) {
            logger$5.info(`Invoking UsernamePasswordCredential with tenant ID: ${tenantId}, clientId: ${clientId} and username: ${username}`);
            this._credential = new UsernamePasswordCredential(tenantId, clientId, username, password, options);
        }
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("EnvironmentCredential-getToken", options);
            if (this._credential) {
                try {
                    const result = yield this._credential.getToken(scopes, newOptions);
                    logger$5.getToken.info(formatSuccess(scopes));
                    return result;
                }
                catch (err) {
                    const code = err.name === AuthenticationErrorName
                        ? api.CanonicalCode.UNAUTHENTICATED
                        : api.CanonicalCode.UNKNOWN;
                    span.setStatus({
                        code,
                        message: err.message
                    });
                    const authenticationError = new AuthenticationError(400, {
                        error: "EnvironmentCredential authentication failed.",
                        error_description: err.message
                            .toString()
                            .split("More details:")
                            .join("")
                    });
                    logger$5.getToken.info(formatError(authenticationError));
                    throw authenticationError;
                }
                finally {
                    span.end();
                }
            }
            // If by this point we don't have a credential, throw an exception so that
            // the user knows the credential was not configured appropriately
            span.setStatus({ code: api.CanonicalCode.UNAUTHENTICATED });
            span.end();
            const error = new CredentialUnavailable("EnvironmentCredential is unavailable. Environment variables are not fully configured.");
            logger$5.getToken.info(formatError(error));
            throw error;
        });
    }
}

// Copyright (c) Microsoft Corporation.
const DefaultScopeSuffix = "/.default";
const ImdsEndpoint = "http://169.254.169.254/metadata/identity/oauth2/token";
const ImdsApiVersion = "2018-02-01";
const AppServiceMsiApiVersion = "2017-09-01";
const logger$6 = credentialLogger("ManagedIdentityCredential");
/**
 * Attempts authentication using a managed identity that has been assigned
 * to the deployment environment.  This authentication type works in Azure VMs,
 * App Service and Azure Functions applications, and inside of Azure Cloud Shell.
 *
 * More information about configuring managed identities can be found here:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview
 */
class ManagedIdentityCredential {
    /**
     * @internal
     * @ignore
     */
    constructor(clientIdOrOptions, options) {
        this.isEndpointUnavailable = null;
        if (typeof clientIdOrOptions === "string") {
            // clientId, options constructor
            this.clientId = clientIdOrOptions;
            this.identityClient = new IdentityClient(options);
        }
        else {
            // options only constructor
            this.identityClient = new IdentityClient(clientIdOrOptions);
        }
    }
    mapScopesToResource(scopes) {
        let scope = "";
        if (Array.isArray(scopes)) {
            if (scopes.length !== 1) {
                throw new Error("To convert to a resource string the specified array must be exactly length 1");
            }
            scope = scopes[0];
        }
        else if (typeof scopes === "string") {
            scope = scopes;
        }
        if (!scope.endsWith(DefaultScopeSuffix)) {
            return scope;
        }
        return scope.substr(0, scope.lastIndexOf(DefaultScopeSuffix));
    }
    createImdsAuthRequest(resource, clientId) {
        const queryParameters = {
            resource,
            "api-version": ImdsApiVersion
        };
        if (clientId) {
            queryParameters.client_id = clientId;
        }
        return {
            url: ImdsEndpoint,
            method: "GET",
            queryParameters,
            headers: {
                Accept: "application/json",
                Metadata: true
            }
        };
    }
    createAppServiceMsiAuthRequest(resource, clientId) {
        const queryParameters = {
            resource,
            "api-version": AppServiceMsiApiVersion
        };
        if (clientId) {
            queryParameters.clientid = clientId;
        }
        return {
            url: process.env.MSI_ENDPOINT,
            method: "GET",
            queryParameters,
            headers: {
                Accept: "application/json",
                secret: process.env.MSI_SECRET
            }
        };
    }
    createCloudShellMsiAuthRequest(resource, clientId) {
        const body = {
            resource
        };
        if (clientId) {
            body.client_id = clientId;
        }
        return {
            url: process.env.MSI_ENDPOINT,
            method: "POST",
            body: qs.stringify(body),
            headers: {
                Accept: "application/json",
                Metadata: true,
                "Content-Type": "application/x-www-form-urlencoded"
            }
        };
    }
    pingImdsEndpoint(resource, clientId, getTokenOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options } = createSpan("ManagedIdentityCredential-pingImdsEndpoint", getTokenOptions);
            const request = this.createImdsAuthRequest(resource, clientId);
            // This will always be populated, but let's make TypeScript happy
            if (request.headers) {
                // Remove the Metadata header to invoke a request error from
                // IMDS endpoint
                delete request.headers.Metadata;
            }
            request.spanOptions = options.tracingOptions && options.tracingOptions.spanOptions;
            try {
                // Create a request with a timeout since we expect that
                // not having a "Metadata" header should cause an error to be
                // returned quickly from the endpoint, proving its availability.
                const webResource = this.identityClient.createWebResource(request);
                webResource.timeout = (options.requestOptions && options.requestOptions.timeout) || 500;
                try {
                    logger$6.info(`Pinging IMDS endpoint`);
                    yield this.identityClient.sendRequest(webResource);
                }
                catch (err) {
                    if ((err instanceof coreHttp.RestError && err.code === coreHttp.RestError.REQUEST_SEND_ERROR) ||
                        err.name === "AbortError") {
                        // Either request failed or IMDS endpoint isn't available
                        logger$6.info(`IMDS endpoint unavailable`);
                        span.setStatus({
                            code: api.CanonicalCode.UNAVAILABLE,
                            message: err.message
                        });
                        return false;
                    }
                }
                // If we received any response, the endpoint is available
                logger$6.info(`IMDS endpoint is available`);
                return true;
            }
            catch (err) {
                logger$6.info(formatError(`Error when accessing IMDS endpoint: ${err.message}`));
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    authenticateManagedIdentity(scopes, checkIfImdsEndpointAvailable, clientId, getTokenOptions) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let authRequestOptions;
            const resource = this.mapScopesToResource(scopes);
            let expiresInParser;
            const { span, options } = createSpan("ManagedIdentityCredential-authenticateManagedIdentity", getTokenOptions);
            try {
                // Detect which type of environment we are running in
                if (process.env.MSI_ENDPOINT) {
                    if (process.env.MSI_SECRET) {
                        // Running in App Service
                        authRequestOptions = this.createAppServiceMsiAuthRequest(resource, clientId);
                        expiresInParser = (requestBody) => {
                            // Parse a date format like "06/20/2019 02:57:58 +00:00" and
                            // convert it into a JavaScript-formatted date
                            return Date.parse(requestBody.expires_on);
                        };
                        logger$6.info(`Using the endpoint and the secret coming form the environment variables: MSI_ENDPOINT=${process.env.MSI_ENDPOINT} and MSI_SECRET=[REDACTED].`);
                    }
                    else {
                        logger$6.info(`Using the endpoint coming form the environment variable MSI_ENDPOINT=${process.env.MSI_ENDPOINT}, and using the cloud shell to proceed with the authentication.`);
                        // Running in Cloud Shell
                        authRequestOptions = this.createCloudShellMsiAuthRequest(resource, clientId);
                    }
                }
                else {
                    expiresInParser = (requestBody) => {
                        if (requestBody.expires_on) {
                            // Use the expires_on timestamp if it's available
                            const expires = +requestBody.expires_on * 1000;
                            logger$6.info(`IMDS using expires_on: ${expires} (original value: ${requestBody.expires_on})`);
                            return expires;
                        }
                        else {
                            // If these aren't possible, use expires_in and calculate a timestamp
                            const expires = Date.now() + requestBody.expires_in * 1000;
                            logger$6.info(`IMDS using expires_in: ${expires} (original value: ${requestBody.expires_in})`);
                            return expires;
                        }
                    };
                    logger$6.info(`Using the IMDS endpoint coming form the environment variable MSI_ENDPOINT=${process.env.MSI_ENDPOINT}, and using the cloud shell to proceed with the authentication.`);
                    // Ping the IMDS endpoint to see if it's available
                    if (!checkIfImdsEndpointAvailable ||
                        (yield this.pingImdsEndpoint(resource, clientId, options))) {
                        // Running in an Azure VM
                        authRequestOptions = this.createImdsAuthRequest(resource, clientId);
                    }
                    else {
                        // Returning null tells the ManagedIdentityCredential that
                        // no MSI authentication endpoints are available
                        return null;
                    }
                }
                const webResource = this.identityClient.createWebResource(Object.assign({ disableJsonStringifyOnBody: true, deserializationMapper: undefined, abortSignal: options.abortSignal, spanOptions: options.tracingOptions && options.tracingOptions.spanOptions }, authRequestOptions));
                const tokenResponse = yield this.identityClient.sendTokenRequest(webResource, expiresInParser);
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? api.CanonicalCode.UNAUTHENTICATED
                    : api.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let result = null;
            const { span, options: newOptions } = createSpan("ManagedIdentityCredential-getToken", options);
            try {
                // isEndpointAvailable can be true, false, or null,
                // the latter indicating that we don't yet know whether
                // the endpoint is available and need to check for it.
                if (this.isEndpointUnavailable !== true) {
                    result = yield this.authenticateManagedIdentity(scopes, this.isEndpointUnavailable === null, this.clientId, newOptions);
                    // If authenticateManagedIdentity returns null, it means no MSI
                    // endpoints are available.  In this case, don't try them in future
                    // requests.
                    this.isEndpointUnavailable = result === null;
                }
                else {
                    const error = new CredentialUnavailable("The managed identity endpoint is not currently available");
                    logger$6.getToken.info(formatError(error));
                    throw error;
                }
                logger$6.getToken.info(formatSuccess(scopes));
                return result;
            }
            catch (err) {
                span.setStatus({
                    code: api.CanonicalCode.UNKNOWN,
                    message: err.message
                });
                if (err.code === "ENETUNREACH") {
                    const error = new CredentialUnavailable("ManagedIdentityCredential is unavailable. No managed identity endpoint found.");
                    logger$6.getToken.info(formatError(error));
                    throw error;
                }
                throw new AuthenticationError(400, {
                    error: "ManagedIdentityCredential authentication failed.",
                    error_description: err.message
                });
            }
            finally {
                if (this.isEndpointUnavailable) {
                    const error = new CredentialUnavailable("ManagedIdentityCredential is unavailable. No managed identity endpoint found.");
                    logger$6.getToken.info(formatError(error));
                    // eslint-disable-next-line no-unsafe-finally
                    throw error;
                }
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
function getSafeWorkingDir() {
    if (process.platform === "win32") {
        if (!process.env.SystemRoot) {
            throw new Error("Azure CLI credential expects a 'SystemRoot' environment variable");
        }
        return process.env.SystemRoot;
    }
    else {
        return "/bin";
    }
}
const logger$7 = credentialLogger("AzureCliCredential");
/**
 * This credential will use the currently logged-in user login information
 * via the Azure CLI ('az') commandline tool.
 * To do so, it will read the user access token and expire time
 * with Azure CLI command "az account get-access-token".
 * To be able to use this credential, ensure that you have already logged
 * in via the 'az' tool using the command "az login" from the commandline.
 */
class AzureCliCredential {
    /**
     * Gets the access token from Azure CLI
     * @param resource The resource to use when getting the token
     */
    getAzureCliAccessToken(resource) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                try {
                    child_process.exec(`az account get-access-token --output json --resource ${resource}`, { cwd: getSafeWorkingDir() }, (error, stdout, stderr) => {
                        resolve({ stdout: stdout, stderr: stderr });
                    });
                }
                catch (err) {
                    reject(err);
                }
            });
        });
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const scope = typeof scopes === "string" ? scopes : scopes[0];
                logger$7.getToken.info(`Using the scope ${scope}`);
                const resource = scope.replace(/\/.default$/, "");
                // Check to make sure the scope we get back is a valid scope
                if (!scope.match(/^[0-9a-zA-Z-.:/]+$/)) {
                    const error = new Error("Invalid scope was specified by the user or calling client");
                    logger$7.getToken.info(formatError(error));
                    throw error;
                }
                let responseData = "";
                const { span } = createSpan("AzureCliCredential-getToken", options);
                this.getAzureCliAccessToken(resource)
                    .then((obj) => {
                    if (obj.stderr) {
                        const isLoginError = obj.stderr.match("(.*)az login(.*)");
                        const isNotInstallError = obj.stderr.match("az:(.*)not found") ||
                            obj.stderr.startsWith("'az' is not recognized");
                        if (isNotInstallError) {
                            const error = new CredentialUnavailable("Azure CLI could not be found.  Please visit https://aka.ms/azure-cli for installation instructions and then, once installed, authenticate to your Azure account using 'az login'.");
                            logger$7.getToken.info(formatError(error));
                            throw error;
                        }
                        else if (isLoginError) {
                            const error = new CredentialUnavailable("Please run 'az login' from a command prompt to authenticate before using this credential.");
                            logger$7.getToken.info(formatError(error));
                            throw error;
                        }
                        const error = new CredentialUnavailable(obj.stderr);
                        logger$7.getToken.info(formatError(error));
                        throw error;
                    }
                    else {
                        responseData = obj.stdout;
                        const response = JSON.parse(responseData);
                        logger$7.getToken.info(formatSuccess(scopes));
                        const returnValue = {
                            token: response.accessToken,
                            expiresOnTimestamp: new Date(response.expiresOn).getTime()
                        };
                        resolve(returnValue);
                        return returnValue;
                    }
                })
                    .catch((err) => {
                    const code = err.name === AuthenticationErrorName
                        ? api.CanonicalCode.UNAUTHENTICATED
                        : api.CanonicalCode.UNKNOWN;
                    span.setStatus({
                        code,
                        message: err.message
                    });
                    logger$7.getToken.info(formatError(err));
                    reject(err);
                });
            });
        });
    }
}

// Copyright (c) Microsoft Corporation.
let keytar;
try {
    keytar = require("keytar");
}
catch (er) {
    keytar = null;
}
const CommonTenantId = "common";
const AzureAccountClientId = "aebc6443-996d-45c2-90f0-388ff96faa56"; // VSC: 'aebc6443-996d-45c2-90f0-388ff96faa56'
const VSCodeUserName = "VS Code Azure";
const logger$8 = credentialLogger("VisualStudioCodeCredential");
/**
 * Attempts to load the tenant from the VSCode configurations of the current OS.
 * If it fails at any point, returns undefined.
 */
function getTenantIdFromVSCode() {
    const commonSettingsPath = ["Code", "User", "settings.json"];
    const homedir = os.homedir();
    function loadTenant(...pathSegments) {
        const settingsPath = path.join(...pathSegments, ...commonSettingsPath);
        const settings = JSON.parse(fs__default.readFileSync(settingsPath, { encoding: "utf8" }));
        return settings["azure.tenant"];
    }
    try {
        let appData;
        switch (process.platform) {
            case "win32":
                appData = process.env.APPDATA;
                return appData ? loadTenant(appData) : undefined;
            case "darwin":
                return loadTenant(homedir, "Library", "Application Support");
            case "linux":
                return loadTenant(homedir, ".config");
            default:
                return;
        }
    }
    catch (e) {
        logger$8.info(`Failed to load the Visual Studio Code configuration file. Error: ${e.message}`);
        return;
    }
}
/**
 * Connect to Azure using the credential provided by the VSCode extension 'Azure Account'.
 * Once the user has logged in via the extension, this credential can share the same refresh token
 * that is cached by the extension.
 */
class VisualStudioCodeCredential {
    /**
     * Creates an instance of VisualStudioCodeCredential to use for automatically authenticating via VSCode.
     *
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(options) {
        this.identityClient = new IdentityClient(options);
        if (options && options.tenantId) {
            this.tenantId = options.tenantId;
        }
        else {
            this.tenantId = CommonTenantId;
        }
    }
    /**
     * Runs preparations for any further getToken request.
     */
    prepare() {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            // Attempts to load the tenant from the VSCode configuration file.
            const settingsTenant = getTenantIdFromVSCode();
            if (settingsTenant) {
                this.tenantId = settingsTenant;
            }
        });
    }
    /**
     * Runs preparations for any further getToken, but only once.
     */
    prepareOnce() {
        if (this.preparePromise) {
            return this.preparePromise;
        }
        this.preparePromise = this.prepare();
        return this.preparePromise;
    }
    /**
     * Returns the token found by searching VSCode's authentication cache or
     * returns null if no token could be found.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                `TokenCredential` implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            yield this.prepareOnce();
            if (!keytar) {
                throw new CredentialUnavailable("Visual Studio Code credential requires the optional dependency 'keytar' to work correctly");
            }
            let scopeString = typeof scopes === "string" ? scopes : scopes.join(" ");
            // Check to make sure the scope we get back is a valid scope
            if (!scopeString.match(/^[0-9a-zA-Z-.:/]+$/)) {
                const error = new Error("Invalid scope was specified by the user or calling client");
                logger$8.getToken.info(formatError(error));
                throw error;
            }
            if (scopeString.indexOf("offline_access") < 0) {
                scopeString += " offline_access";
            }
            const refreshToken = yield keytar.findPassword(VSCodeUserName);
            if (refreshToken) {
                const tokenResponse = yield this.identityClient.refreshAccessToken(this.tenantId, AzureAccountClientId, scopeString, refreshToken, undefined);
                if (tokenResponse) {
                    logger$8.getToken.info(formatSuccess(scopes));
                    return tokenResponse.accessToken;
                }
                else {
                    const error = new CredentialUnavailable("Could not retrieve the token associated with Visual Studio Code. Have you connected using the 'Azure Account' extension recently?");
                    logger$8.getToken.info(formatError(error));
                    throw error;
                }
            }
            else {
                const error = new CredentialUnavailable("Could not retrieve the token associated with Visual Studio Code. Did you connect using the 'Azure Account' extension?");
                logger$8.getToken.info(formatError(error));
                throw error;
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * Provides a default {@link ChainedTokenCredential} configuration for
 * applications that will be deployed to Azure.  The following credential
 * types will be tried, in order:
 *
 * - {@link EnvironmentCredential}
 * - {@link ManagedIdentityCredential}
 *
 * Consult the documentation of these credential types for more information
 * on how they attempt authentication.
 */
class DefaultAzureCredential extends ChainedTokenCredential {
    /**
     * Creates an instance of the DefaultAzureCredential class.
     *
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tokenCredentialOptions) {
        const credentials = [];
        credentials.push(new EnvironmentCredential(tokenCredentialOptions));
        credentials.push(new ManagedIdentityCredential(tokenCredentialOptions));
        if (process.env.AZURE_CLIENT_ID) {
            credentials.push(new ManagedIdentityCredential((tokenCredentialOptions === null || tokenCredentialOptions === void 0 ? void 0 : tokenCredentialOptions.managedIdentityClientId) || process.env.AZURE_CLIENT_ID, tokenCredentialOptions));
        }
        credentials.push(new AzureCliCredential());
        credentials.push(new VisualStudioCodeCredential(tokenCredentialOptions));
        super(...credentials);
        this.UnavailableMessage =
            "DefaultAzureCredential => failed to retrieve a token from the included credentials";
    }
}

// Copyright (c) Microsoft Corporation.
const BrowserNotSupportedError = new Error("InteractiveBrowserCredential is not supported in Node.js.");
const logger$9 = credentialLogger("InteractiveBrowserCredential");
/**
 * Enables authentication to Azure Active Directory inside of the web browser
 * using the interactive login flow, either via browser redirects or a popup
 * window.  This credential is not currently supported in Node.js.
 */
class InteractiveBrowserCredential {
    constructor(options) {
        logger$9.info(formatError(BrowserNotSupportedError));
        throw BrowserNotSupportedError;
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        logger$9.getToken.info(formatError(BrowserNotSupportedError));
        throw BrowserNotSupportedError;
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * A wrapper for setTimeout that resolves a promise after t milliseconds.
 * @internal
 * @param {number} t The number of milliseconds to be delayed.
 * @returns {Promise<void>} Resolved promise
 */
function delay(t) {
    return new Promise((resolve) => setTimeout(() => resolve(), t));
}

// Copyright (c) Microsoft Corporation.
const logger$a = credentialLogger("DeviceCodeCredential");
/**
 * Enables authentication to Azure Active Directory using a device code
 * that the user can enter into https://microsoft.com/devicelogin.
 */
class DeviceCodeCredential {
    /**
     * Creates an instance of DeviceCodeCredential with the details needed
     * to initiate the device code authorization flow with Azure Active Directory.
     *
     * @param tenantId The Azure Active Directory tenant (directory) ID or name.
     *                 'organizations' may be used when dealing with multi-tenant scenarios.
     * @param clientId The client (application) ID of an App Registration in the tenant.
     * @param userPromptCallback A callback function that will be invoked to show
                                 {@link DeviceCodeInfo} to the user.
     * @param options Options for configuring the client which makes the authentication request.
     */
    constructor(tenantId, clientId, userPromptCallback, options) {
        this.lastTokenResponse = null;
        this.identityClient = new IdentityClient(options);
        this.tenantId = tenantId;
        this.clientId = clientId;
        this.userPromptCallback = userPromptCallback;
    }
    sendDeviceCodeRequest(scope, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("DeviceCodeCredential-sendDeviceCodeRequest", options);
            try {
                const webResource = this.identityClient.createWebResource({
                    url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/devicecode`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        client_id: this.clientId,
                        scope
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                });
                logger$a.info("Sending devicecode request");
                const response = yield this.identityClient.sendRequest(webResource);
                if (!(response.status === 200 || response.status === 201)) {
                    throw new AuthenticationError(response.status, response.bodyAsText);
                }
                return response.parsedBody;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? api.CanonicalCode.UNAUTHENTICATED
                    : api.CanonicalCode.UNKNOWN;
                if (err.name === AuthenticationErrorName) {
                    logger$a.info(`Failed to authenticate ${err.errorResponse.errorDescription}`);
                }
                else {
                    logger$a.info(`Failed to authenticate ${err}`);
                }
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    pollForToken(deviceCodeResponse, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            let tokenResponse = null;
            const { span, options: newOptions } = createSpan("DeviceCodeCredential-pollForToken", options);
            try {
                const webResource = this.identityClient.createWebResource({
                    url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,
                    method: "POST",
                    disableJsonStringifyOnBody: true,
                    deserializationMapper: undefined,
                    body: qs.stringify({
                        grant_type: "urn:ietf:params:oauth:grant-type:device_code",
                        client_id: this.clientId,
                        device_code: deviceCodeResponse.device_code
                    }),
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/x-www-form-urlencoded"
                    },
                    abortSignal: options && options.abortSignal,
                    spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                });
                while (tokenResponse === null) {
                    try {
                        yield delay(deviceCodeResponse.interval * 1000);
                        // Check the abort signal before sending the request
                        if (options && options.abortSignal && options.abortSignal.aborted) {
                            return null;
                        }
                        tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                    }
                    catch (err) {
                        if (err.name === AuthenticationErrorName) {
                            switch (err.errorResponse.error) {
                                case "authorization_pending":
                                    break;
                                case "authorization_declined":
                                    return null;
                                case "expired_token":
                                    throw err;
                                case "bad_verification_code":
                                    throw err;
                                default:
                                    // Any other error should be rethrown
                                    throw err;
                            }
                        }
                        else {
                            throw err;
                        }
                    }
                }
                return tokenResponse;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? api.CanonicalCode.UNAUTHENTICATED
                    : api.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("DeviceCodeCredential-getToken", options);
            try {
                let tokenResponse = null;
                let scopeString = typeof scopes === "string" ? scopes : scopes.join(" ");
                if (scopeString.indexOf("offline_access") < 0) {
                    scopeString += " offline_access";
                }
                // Try to use the refresh token first
                if (this.lastTokenResponse && this.lastTokenResponse.refreshToken) {
                    tokenResponse = yield this.identityClient.refreshAccessToken(this.tenantId, this.clientId, scopeString, this.lastTokenResponse.refreshToken, undefined, // clientSecret not needed for device code auth
                    undefined, newOptions);
                }
                if (tokenResponse === null) {
                    const deviceCodeResponse = yield this.sendDeviceCodeRequest(scopeString, newOptions);
                    this.userPromptCallback({
                        userCode: deviceCodeResponse.user_code,
                        verificationUri: deviceCodeResponse.verification_uri,
                        message: deviceCodeResponse.message
                    });
                    tokenResponse = yield this.pollForToken(deviceCodeResponse, newOptions);
                }
                this.lastTokenResponse = tokenResponse;
                logger$a.getToken.info(formatSuccess(scopes));
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? api.CanonicalCode.UNAUTHENTICATED
                    : api.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                logger$a.getToken.info(err);
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
const logger$b = credentialLogger("AuthorizationCodeCredential");
/**
 * Enables authentication to Azure Active Directory using an authorization code
 * that was obtained through the authorization code flow, described in more detail
 * in the Azure Active Directory documentation:
 *
 * https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow
 */
class AuthorizationCodeCredential {
    /**
     * @ignore
     * @internal
     */
    constructor(tenantId, clientId, clientSecretOrAuthorizationCode, authorizationCodeOrRedirectUri, redirectUriOrOptions, options) {
        this.lastTokenResponse = null;
        this.clientId = clientId;
        this.tenantId = tenantId;
        if (typeof redirectUriOrOptions === "string") {
            // the clientId+clientSecret constructor
            this.clientSecret = clientSecretOrAuthorizationCode;
            this.authorizationCode = authorizationCodeOrRedirectUri;
            this.redirectUri = redirectUriOrOptions;
            // options okay
        }
        else {
            // clientId only
            this.clientSecret = undefined;
            this.authorizationCode = clientSecretOrAuthorizationCode;
            this.redirectUri = authorizationCodeOrRedirectUri;
            options = redirectUriOrOptions;
        }
        this.identityClient = new IdentityClient(options);
    }
    /**
     * Authenticates with Azure Active Directory and returns an access token if
     * successful.  If authentication cannot be performed at this time, this method may
     * return null.  If an error occurs during authentication, an {@link AuthenticationError}
     * containing failure details will be thrown.
     *
     * @param scopes The list of scopes for which the token will have access.
     * @param options The options used to configure any requests this
     *                TokenCredential implementation might make.
     */
    getToken(scopes, options) {
        return tslib.__awaiter(this, void 0, void 0, function* () {
            const { span, options: newOptions } = createSpan("AuthorizationCodeCredential-getToken", options);
            try {
                let tokenResponse = null;
                let scopeString = typeof scopes === "string" ? scopes : scopes.join(" ");
                if (scopeString.indexOf("offline_access") < 0) {
                    scopeString += " offline_access";
                }
                // Try to use the refresh token first
                if (this.lastTokenResponse && this.lastTokenResponse.refreshToken) {
                    tokenResponse = yield this.identityClient.refreshAccessToken(this.tenantId, this.clientId, scopeString, this.lastTokenResponse.refreshToken, this.clientSecret, undefined, newOptions);
                }
                if (tokenResponse === null) {
                    const webResource = this.identityClient.createWebResource({
                        url: `${this.identityClient.authorityHost}/${this.tenantId}/oauth2/v2.0/token`,
                        method: "POST",
                        disableJsonStringifyOnBody: true,
                        deserializationMapper: undefined,
                        body: qs.stringify({
                            client_id: this.clientId,
                            grant_type: "authorization_code",
                            scope: scopeString,
                            code: this.authorizationCode,
                            redirect_uri: this.redirectUri,
                            client_secret: this.clientSecret
                        }),
                        headers: {
                            Accept: "application/json",
                            "Content-Type": "application/x-www-form-urlencoded"
                        },
                        abortSignal: options && options.abortSignal,
                        spanOptions: newOptions.tracingOptions && newOptions.tracingOptions.spanOptions
                    });
                    tokenResponse = yield this.identityClient.sendTokenRequest(webResource);
                }
                this.lastTokenResponse = tokenResponse;
                logger$b.getToken.info(formatSuccess(scopes));
                return (tokenResponse && tokenResponse.accessToken) || null;
            }
            catch (err) {
                const code = err.name === AuthenticationErrorName
                    ? api.CanonicalCode.UNAUTHENTICATED
                    : api.CanonicalCode.UNKNOWN;
                span.setStatus({
                    code,
                    message: err.message
                });
                logger$b.getToken.info(formatError(err));
                throw err;
            }
            finally {
                span.end();
            }
        });
    }
}

// Copyright (c) Microsoft Corporation.
(function (AzureAuthorityHosts) {
    /**
     * China-based Azure Authority Host
     */
    AzureAuthorityHosts["AzureChina"] = "https://login.chinacloudapi.cn";
    /**
     * Germany-based Azure Authority Host
     */
    AzureAuthorityHosts["AzureGermany"] = "https://login.microsoftonline.de";
    /**
     * US Government Azure Authority Host
     */
    AzureAuthorityHosts["AzureGovernment"] = "https://login.microsoftonline.us";
    /**
     * Public Cloud Azure Authority Host
     */
    AzureAuthorityHosts["AzurePublicCloud"] = "https://login.microsoftonline.com";
})(exports.AzureAuthorityHosts || (exports.AzureAuthorityHosts = {}));

// Copyright (c) Microsoft Corporation.
/**
 * Returns a new instance of the {@link DefaultAzureCredential}.
 */
function getDefaultAzureCredential() {
    return new DefaultAzureCredential();
}

exports.AggregateAuthenticationError = AggregateAuthenticationError;
exports.AggregateAuthenticationErrorName = AggregateAuthenticationErrorName;
exports.AuthenticationError = AuthenticationError;
exports.AuthenticationErrorName = AuthenticationErrorName;
exports.AuthorizationCodeCredential = AuthorizationCodeCredential;
exports.AzureCliCredential = AzureCliCredential;
exports.ChainedTokenCredential = ChainedTokenCredential;
exports.ClientCertificateCredential = ClientCertificateCredential;
exports.ClientSecretCredential = ClientSecretCredential;
exports.CredentialUnavailable = CredentialUnavailable;
exports.DefaultAzureCredential = DefaultAzureCredential;
exports.DeviceCodeCredential = DeviceCodeCredential;
exports.EnvironmentCredential = EnvironmentCredential;
exports.InteractiveBrowserCredential = InteractiveBrowserCredential;
exports.ManagedIdentityCredential = ManagedIdentityCredential;
exports.UsernamePasswordCredential = UsernamePasswordCredential;
exports.VisualStudioCodeCredential = VisualStudioCodeCredential;
exports.getDefaultAzureCredential = getDefaultAzureCredential;
exports.logger = logger;
//# sourceMappingURL=index.js.map
